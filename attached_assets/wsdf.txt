import { Request, Response } from 'express';
import Imap from 'imap';
import { simpleParser } from 'mailparser';
import { db } from '../db';
import { redirectUrls, redirectCampaigns, processedOrders, globalSettings } from '../../shared/schema';
import { eq, and, gte } from 'drizzle-orm';
import { Readable } from 'stream';
import dotenv from 'dotenv';
import NodeCache from 'node-cache';
import { storage } from '../storage';

// OPTIMIZATION: Use memory-efficient caching for processed orders to handle millions of landers
// This in-memory cache stores only order IDs that have been processed, using minimal memory
// Cache TTL is extended to 24 hours for better duplicate prevention over longer periods
export const processedOrdersCache = new NodeCache({ 
  stdTTL: 86400, // 24 hour cache for processed order IDs (extended from 1 hour)
  checkperiod: 1800, // Check every 30 minutes (increased from 10 minutes)
  useClones: false, // Don't clone values to save memory
  maxKeys: -1 // No limit on keys (we'll handle memory usage in other ways)
});

// OPTIMIZATION: Intelligent check for already processed orders
// This function efficiently checks both the cache and database to determine
// if an order ID has already been processed, using minimal memory and database calls
async function checkProcessedOrderEfficient(orderId: string): Promise<{exists: boolean, source: string | null}> {
  // First check in memory cache for ultra-fast response
  const cachedResult = processedOrdersCache.get(orderId);
  if (cachedResult) {
    return { exists: true, source: 'memory_cache' };
  }
  
  // Get entire order history (no time limitation for stronger duplicate prevention)
  try {
    console.log(`[Order Check] Checking ALL processed orders for order: ${orderId}`);
    
    // Check in processed_orders table first (no time limit - check all history)
    const existingProcessedOrder = await db.query.processedOrders.findFirst({
      where: eq(processedOrders.orderId, orderId),
      columns: { id: true } // Select only ID field to minimize data transfer
    });
    
    if (existingProcessedOrder) {
      // Found in processed_orders, cache it for future ultra-fast lookups
      processedOrdersCache.set(orderId, true);
      return { exists: true, source: 'processed_orders_history_all' };
    }
    
    // Check in redirect URLs table for all history
    const existingUrl = await db.query.redirectUrls.findFirst({
      where: eq(redirectUrls.name, orderId),
      columns: { id: true } // Select only ID field to minimize data transfer
    });
    
    if (existingUrl) {
      // Also cache this result
      processedOrdersCache.set(orderId, true);
      return { exists: true, source: 'redirectUrls_table_all' };
    }
    
    // Not found in either table
    return { exists: false, source: null };
  } catch (error) {
    console.error(`Error checking processed order: ${orderId}`, error);
    // In case of database error, be conservative and assume it doesn't exist
    return { exists: false, source: null };
  }
}

// Interface for extracted order data
interface OrderData {
  orderId: string;
  url: string;
  quantity: number;
  processed: boolean;
  source: string;
}

// Always reload environment variables to ensure we have the latest values
dotenv.config();

// In-memory cache for instant access to email processor settings
// This allows for immediate settings updates without environment variable reload delays
const settingsCache = {
  targetCampaignId: process.env.TARGET_CAMPAIGN_ID ? parseInt(process.env.TARGET_CAMPAIGN_ID) : null,
  targetCampaignName: process.env.TARGET_CAMPAIGN_NAME || 'Ttets', // Default to a known campaign 
  whitelistedSenders: (process.env.WHITELISTED_SENDERS || 'help@donot-reply.in').split(',').map(s => s.trim()),
  subjectPattern: process.env.SUBJECT_PATTERN || 'New Order Received (?:\\[|\\s+)(\\d+)(?:\\]|\\s*$)',
  devMode: process.env.EMAIL_DEV_MODE === 'true',
  // Auto delete emails settings with defaults - default to false if not explicitly true
  autoDeleteEmails: process.env.AUTO_DELETE_EMAILS === 'true' ? true : false,
  deleteAfterMinutes: process.env.DELETE_AFTER_MINUTES ? parseInt(process.env.DELETE_AFTER_MINUTES) : 1440, // Default 24 hours
  // Email age filter settings with defaults - default to true if not explicitly false
  limitEmailAge: process.env.LIMIT_EMAIL_AGE === 'false' ? false : true,
  maxEmailAgeMinutes: process.env.MAX_EMAIL_AGE_MINUTES ? parseInt(process.env.MAX_EMAIL_AGE_MINUTES) : 14400 // Default 10 days (14400 minutes)
};

console.log('[Email Processor] Initialized with settings:', {
  targetCampaignId: settingsCache.targetCampaignId,
  targetCampaignName: settingsCache.targetCampaignName
});

// Force immediate email check with current settings
// This function is exported so it can be called from other modules
export async function forceImmediateEmailCheck(): Promise<boolean> {
  console.log('[Email Processor] ðŸš¨ FORCING IMMEDIATE EMAIL CHECK WITH LATEST SETTINGS');
  console.log('[Email Processor] Current target campaign ID:', settingsCache.targetCampaignId);
  
  try {
    // Clear any existing timer
    if (emailProcessorTimer) {
      clearTimeout(emailProcessorTimer);
      emailProcessorTimer = null;
    }
    
    // Force reset running state to ensure we can start a fresh check
    emailProcessorRunning = false;
    
    // Run the email check directly and wait for it to complete
    await runEmailCheck();
    
    // Schedule next check after this forced check completes
    scheduleNextEmailCheck(60000); // Regular interval after force check
    
    return true;
  } catch (err) {
    console.error('[Email Processor] Error during forced immediate email check:', err);
    // Still schedule next check even if this one failed
    scheduleNextEmailCheck(60000);
    return false;
  }
}

// Function to update settings cache (called when settings are changed via API)
export function updateSettingsCache(newSettings: any) {
  console.log('[Settings] Updating in-memory settings cache for instant effect');
  
  // Track if campaign ID changed to trigger special handling
  let campaignIdChanged = false;
  let oldCampaignId = settingsCache.targetCampaignId;
  
  if (newSettings.targetCampaignId !== undefined) {
    settingsCache.targetCampaignId = newSettings.targetCampaignId;
    campaignIdChanged = (oldCampaignId !== newSettings.targetCampaignId);
    
    if (campaignIdChanged) {
      console.log(`[Settings] ðŸš¨ CAMPAIGN ID CHANGED from ${oldCampaignId} to ${newSettings.targetCampaignId} - will force immediate processing`);
    }
  }
  
  if (newSettings.targetCampaignName !== undefined) {
    settingsCache.targetCampaignName = newSettings.targetCampaignName;
  }
  
  if (newSettings.whitelistedSenders !== undefined) {
    settingsCache.whitelistedSenders = newSettings.whitelistedSenders;
  }
  
  if (newSettings.subjectPattern !== undefined) {
    settingsCache.subjectPattern = newSettings.subjectPattern;
  }
  
  // Update auto-delete settings
  if (newSettings.autoDeleteEmails !== undefined) {
    // Convert to strict boolean
    settingsCache.autoDeleteEmails = newSettings.autoDeleteEmails === true;
    console.log('[Settings] Updated autoDeleteEmails to:', settingsCache.autoDeleteEmails);
  }
  
  if (newSettings.deleteAfterMinutes !== undefined) {
    settingsCache.deleteAfterMinutes = newSettings.deleteAfterMinutes;
  }
  
  // Update email age filter settings
  if (newSettings.limitEmailAge !== undefined) {
    // Convert to strict boolean
    settingsCache.limitEmailAge = newSettings.limitEmailAge === true;
    console.log('[Settings] Updated limitEmailAge to:', settingsCache.limitEmailAge);
  }
  
  if (newSettings.maxEmailAgeMinutes !== undefined) {
    settingsCache.maxEmailAgeMinutes = newSettings.maxEmailAgeMinutes;
  }
  
  console.log('[Settings] Updated settings cache:', settingsCache);
  
  // CRITICAL FIX: For campaign ID changes, we need to ensure immediate application
  // by directly calling the runEmailCheck function instead of just scheduling it
  if (campaignIdChanged) {
    console.log('[Settings] Campaign ID changed - forcing IMMEDIATE email check with high priority');
    // Use setTimeout with 0 delay to execute right after this function completes
    setTimeout(() => {
      forceImmediateEmailCheck()
        .then(success => {
          console.log(`[Settings] Immediate campaign change email check ${success ? 'succeeded' : 'failed'}`);
        })
        .catch((err: any) => {
          console.error('[Settings] Error in immediate campaign change email check:', err?.message || err);
        });
    }, 0);
  } else {
    // For other changes, use the normal schedule approach
    // IMMEDIATE APPLICATION: Restart email processing system to apply changes instantly
    if (emailProcessorTimer) {
      clearTimeout(emailProcessorTimer);
      emailProcessorTimer = null;
    }
    
    // Force reset running state to ensure we can start a fresh check
    emailProcessorRunning = false;
    
    // Immediately trigger a new email check with the updated settings
    console.log('[Settings] Forcing immediate email check with new settings');
    scheduleNextEmailCheck(100); // Set a very short delay (100ms) to allow this function to return first
  }
}

// Function to get current email configuration
// Now uses in-memory cache for instant access to the most current settings
function getEmailConfig() {
  return {
    whitelist: {
      senders: settingsCache.whitelistedSenders,
      subjectPattern: new RegExp(settingsCache.subjectPattern, 'i'),
    },
    targetCampaignName: settingsCache.targetCampaignName,
    targetCampaignId: settingsCache.targetCampaignId,
    devMode: settingsCache.devMode,
    // Auto delete email settings
    autoDeleteEmails: settingsCache.autoDeleteEmails,
    deleteAfterMinutes: settingsCache.deleteAfterMinutes,
    // Email age filter settings
    limitEmailAge: settingsCache.limitEmailAge,
    maxEmailAgeMinutes: settingsCache.maxEmailAgeMinutes
  };
}

// Helper function to create IMAP connection with improved error handling
function createImapConnection(): Imap {
  if (!process.env.GMAIL_USERNAME || !process.env.GMAIL_APP_PASSWORD) {
    throw new Error('Gmail credentials not configured');
  }

  console.log(`[IMAP] Creating connection with username: ${process.env.GMAIL_USERNAME}`);
  
  // Create a more resilient IMAP connection with better error handling
  const imap = new Imap({
    user: process.env.GMAIL_USERNAME,
    password: process.env.GMAIL_APP_PASSWORD,
    host: 'imap.gmail.com',
    port: 993,
    tls: true,
    tlsOptions: { 
      rejectUnauthorized: false,
      servername: 'imap.gmail.com' 
    },
    authTimeout: 30000, // Longer timeout
    connTimeout: 30000, // Connection timeout
    keepalive: { 
      interval: 10000, // 10 seconds
      idleInterval: 60000, // 1 minute
      forceNoop: true 
    },
    debug: (message: string) => {
      // Only log debug messages if in development
      if (process.env.NODE_ENV === 'development' || process.env.EMAIL_DEV_MODE === 'true') {
        console.log(`[IMAP Debug] ${message}`);
      }
    }
  });
  
  // Add error handler to prevent unhandled errors
  imap.on('error', (err: Error) => {
    console.error('[IMAP] Connection error:', err.message);
    // Make sure we don't have hanging connections
    try {
      if (imap.state !== 'disconnected') {
        imap.end();
      }
    } catch (e: any) {
      console.error('[IMAP] Error during connection cleanup:', e?.message || e);
    }
  });
  
  // Add end handler to ensure we know when the connection ends
  imap.once('end', () => {
    console.log('[IMAP] Connection ended');
  });
  
  return imap;
}

// Extract order data from email content
function extractOrderDetails(emailBody: string): OrderData | null {
  try {
    console.log('[Email Extraction] Processing email body:', emailBody);
    
    // Initialize with default values
    const orderData: OrderData = {
      orderId: '',
      url: '',
      quantity: 0,
      processed: false,
      source: 'email'
    };

    // Extract Order ID - add more patterns
    let orderIdMatch = emailBody.match(/Order Id\s*:\s*([A-Za-z0-9-_]+)/i);
    if (!orderIdMatch) {
      orderIdMatch = emailBody.match(/Order ID\s*:\s*([A-Za-z0-9-_]+)/i);
    }
    if (!orderIdMatch) {
      orderIdMatch = emailBody.match(/Order Number\s*:\s*([A-Za-z0-9-_]+)/i);
    }
    if (!orderIdMatch) {
      orderIdMatch = emailBody.match(/ID\s*:\s*([A-Za-z0-9-_]+)/i);
    }
    
    console.log('[Email Extraction] Order ID match:', orderIdMatch ? orderIdMatch[0] : 'No match');
    
    if (orderIdMatch && orderIdMatch[1]) {
      orderData.orderId = orderIdMatch[1].trim();
      console.log('[Email Extraction] Extracted Order ID:', orderData.orderId);
    } else {
      console.log('[Email Extraction] Failed to extract Order ID');
      return null; // Order ID is required
    }

    // Extract URL - multiple patterns with enhanced robustness
    let urlMatch = emailBody.match(/Url\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    if (!urlMatch) {
      urlMatch = emailBody.match(/URL\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    }
    if (!urlMatch) {
      urlMatch = emailBody.match(/Link\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    }
    if (!urlMatch) {
      // Try to find URL patterns with labels
      urlMatch = emailBody.match(/Landing Page\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    }
    if (!urlMatch) {
      urlMatch = emailBody.match(/Offer URL\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    }
    if (!urlMatch) {
      urlMatch = emailBody.match(/Offer Link\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
    }
    if (!urlMatch) {
      // Try to find URL enclosed in brackets, common in HTML emails
      urlMatch = emailBody.match(/<(https?:\/\/[^<>\s]+)>/i);
    }
    if (!urlMatch) {
      // Try to find any URL in the text as last resort
      urlMatch = emailBody.match(/(https?:\/\/[^\s\n<>"']+)/i);
    }
    
    console.log('[Email Extraction] URL match:', urlMatch ? urlMatch[0] : 'No match');
    
    if (urlMatch && urlMatch[1]) {
      orderData.url = urlMatch[1].trim();
      console.log('[Email Extraction] Extracted URL:', orderData.url);
    } else {
      console.log('[Email Extraction] Failed to extract URL');
      return null; // URL is required
    }

    // Extract Quantity - multiple patterns with enhanced robustness
    let quantityMatch = emailBody.match(/Quantity\s*:\s*(\d+)/i);
    if (!quantityMatch) {
      quantityMatch = emailBody.match(/Clicks\s*:\s*(\d+)/i);
    }
    if (!quantityMatch) {
      quantityMatch = emailBody.match(/Amount\s*:\s*(\d+)/i);
    }
    if (!quantityMatch) {
      quantityMatch = emailBody.match(/Total\s*:\s*(\d+)/i);
    }
    if (!quantityMatch) {
      quantityMatch = emailBody.match(/Count\s*:\s*(\d+)/i);
    }
    if (!quantityMatch) {
      quantityMatch = emailBody.match(/Number of Clicks\s*:\s*(\d+)/i);
    }
    if (!quantityMatch) {
      // Extract any plain number in the text as a last resort
      // Only if it's a reasonable click amount (between 10 and 10000)
      const plainNumbers = emailBody.match(/\b(\d{2,5})\b/g);
      if (plainNumbers && plainNumbers.length > 0) {
        // Filter numbers that are in reasonable click amount range (10-10000)
        const possibleQuantities = plainNumbers
          .map((num: string) => parseInt(num, 10))
          .filter((num: number) => num >= 10 && num <= 10000);
          
        if (possibleQuantities.length > 0) {
          // Use the first number in our range
          quantityMatch = ['', possibleQuantities[0].toString()];
          console.log(`[Email Extraction] Found quantity from plain number in text: ${quantityMatch[1]}`);
        }
      }
    }
    
    console.log('[Email Extraction] Quantity match:', quantityMatch ? quantityMatch[0] : 'No match');
    
    if (quantityMatch && quantityMatch[1]) {
      orderData.quantity = parseInt(quantityMatch[1].trim(), 10);
      console.log('[Email Extraction] Extracted Quantity:', orderData.quantity);
    } else {
      console.log('[Email Extraction] Failed to extract Quantity');
      return null; // Quantity is required
    }

    // All required data was found
    orderData.processed = true;
    console.log('[Email Extraction] Successfully extracted order data:', orderData);
    return orderData;
  } catch (error) {
    console.error('Error extracting order details:', error);
    return null;
  }
}

// Main function to process emails and add URLs to campaign
export async function processNewEmails(req: Request, res: Response) {
  try {
    let campaignId: number;
    
    // Get the latest configuration
    const emailConfig = getEmailConfig();
    
    // If a specific campaign ID is configured, use that directly
    if (emailConfig.targetCampaignId) {
      // Verify the campaign exists
      const campaign = await db.query.redirectCampaigns.findFirst({
        where: eq(redirectCampaigns.id, emailConfig.targetCampaignId)
      });
      
      if (!campaign) {
        return res.status(404).json({ 
          success: false, 
          message: `Target campaign with ID ${emailConfig.targetCampaignId} not found` 
        });
      }
      
      campaignId = emailConfig.targetCampaignId;
    } else {
      // Otherwise, find the campaign by name
      const campaign = await db.query.redirectCampaigns.findFirst({
        where: eq(redirectCampaigns.name, emailConfig.targetCampaignName)
      });

      if (!campaign) {
        return res.status(404).json({ 
          success: false, 
          message: `Target campaign '${emailConfig.targetCampaignName}' not found` 
        });
      }
      
      campaignId = campaign.id;
    }
    const imap = createImapConnection();
    let processedEmails: any[] = [];
    const addedUrls: any[] = [];
    let connectionError: Error | null = null;

    imap.once('ready', async () => {
      try {
        // Open the inbox in readonly mode first to get unread emails
        imap.openBox('INBOX', true, async (err, box) => {
          if (err) {
            imap.end();
            return res.status(500).json({ 
              success: false, 
              message: 'Failed to open inbox', 
              error: err.message 
            });
          }

          // Search all emails instead of using SINCE as it's causing compatibility issues
          // We'll filter timestamps after retrieval
          console.log(`[Email Processing] Searching for all emails (will filter to last 10 days after retrieval)`);
          imap.search(['ALL'], async (err, results) => {
            if (err) {
              imap.end();
              return res.status(500).json({ 
                success: false, 
                message: 'Failed to search for unread emails', 
                error: err.message 
              });
            }

            if (results.length === 0) {
              imap.end();
              return res.json({ 
                success: true, 
                message: 'No emails found in inbox', 
                processed: 0 
              });
            }
            
            console.log(`[Email Processing] Found ${results.length} emails in inbox`); 

            // Process emails in reverse order (newer first)
            results.sort((a, b) => b - a);

            const fetch = imap.fetch(results, {
              bodies: ['HEADER.FIELDS (FROM TO SUBJECT)', ''],
              struct: true,
              markSeen: false // Don't mark as seen yet, we'll do it later if processing succeeds
            });

            fetch.on('message', (msg, seqno) => {
              const emailData: any = {
                id: seqno,
                uid: null,
                from: '',
                subject: '',
                body: '',
                orderData: null,
                isWhitelisted: false,
                successfullyProcessed: false, // Flag to track if this email was successfully processed
                date: null // Will be filled from message attributes
              };

              msg.on('body', (stream: Readable, info) => {
                let buffer = '';
                stream.on('data', (chunk) => {
                  buffer += chunk.toString('utf8');
                });

                stream.once('end', () => {
                  if (info.which.startsWith('HEADER')) {
                    const headers = Imap.parseHeader(buffer);
                    emailData.from = headers.from?.[0] || '';
                    emailData.subject = headers.subject?.[0] || '';
                    
                    // Get latest configuration
                    const emailConfig = getEmailConfig();
                    
                    // In development mode, accept all emails for testing
                    if (emailConfig.devMode) {
                      emailData.isWhitelisted = true;
                      console.log(`[Email Whitelist Debug] DEV MODE ON - Processing all emails regardless of sender.`);
                    } else {
                      // Check if this is from a whitelisted sender
                      emailData.isWhitelisted = emailConfig.whitelist.senders.some(
                        (sender: string) => emailData.from.includes(sender)
                      );
                    }
                    
                    // Debug logging for whitelist checking
                    console.log(`[Email Whitelist Debug] From: ${emailData.from}, Whitelist: ${emailConfig.whitelist.senders.join(',')} => Whitelisted: ${emailData.isWhitelisted}`);
                    
                    // Check if subject matches our pattern
                    const subjectMatch = emailData.subject.match(emailConfig.whitelist.subjectPattern);
                    console.log(`[Email Subject Debug] Subject: "${emailData.subject}", Pattern match:`, subjectMatch ? `Match found: ${subjectMatch[1]}` : 'No match');
                    
                    if (subjectMatch && subjectMatch[1]) {
                      emailData.orderId = subjectMatch[1];
                      console.log(`[Email Subject Debug] Extracted Order ID from subject: ${emailData.orderId}`);
                    }
                  } else {
                    // Parse the message body
                    simpleParser(buffer, (err: any, parsed) => {
                      if (err) {
                        console.error('Error parsing email:', err?.message || err);
                        return;
                      }
                      
                      emailData.body = parsed.text || '';
                      
                      // Extract order details if this is a whitelisted email
                      if (emailData.isWhitelisted) {
                        emailData.orderData = extractOrderDetails(emailData.body);
                        
                        // If we have an orderId from the subject but no valid order data extracted
                        // from the body, create an order data object with the subject order ID
                        if (emailData.orderId && (!emailData.orderData || !emailData.orderData.processed)) {
                          console.log(`[Email Extraction] Using Order ID from subject: ${emailData.orderId}`);
                          
                          // Try to extract just URL and quantity from the email body
                          // since we already have the order ID from the subject
                          let url = '';
                          let quantity = 100; // Default quantity if not found
                          
                          // Extract URL using the same enhanced patterns as in extractOrderDetails
                          let urlMatch = emailData.body.match(/Url\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/URL\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/Link\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/Landing Page\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/Offer URL\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/Offer Link\s*:\s*(https?:\/\/[^\s\n<>"]+)/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/<(https?:\/\/[^<>\s]+)>/i);
                          if (!urlMatch) urlMatch = emailData.body.match(/(https?:\/\/[^\s\n<>"']+)/i);
                          
                          if (urlMatch && urlMatch[1]) {
                            url = urlMatch[1].trim();
                            console.log(`[Email Extraction] Extracted URL with subject fallback: ${url}`);
                            
                            // Extract Quantity with the same enhanced patterns
                            let quantityMatch = emailData.body.match(/Quantity\s*:\s*(\d+)/i);
                            if (!quantityMatch) quantityMatch = emailData.body.match(/Clicks\s*:\s*(\d+)/i);
                            if (!quantityMatch) quantityMatch = emailData.body.match(/Amount\s*:\s*(\d+)/i);
                            if (!quantityMatch) quantityMatch = emailData.body.match(/Total\s*:\s*(\d+)/i);
                            if (!quantityMatch) quantityMatch = emailData.body.match(/Count\s*:\s*(\d+)/i);
                            if (!quantityMatch) quantityMatch = emailData.body.match(/Number of Clicks\s*:\s*(\d+)/i);
                            
                            // Try to extract any reasonable number as a last resort
                            if (!quantityMatch) {
                              const plainNumbers = emailData.body.match(/\b(\d{2,5})\b/g);
                              if (plainNumbers && plainNumbers.length > 0) {
                                // Filter numbers that are in reasonable click amount range (10-10000)
                                const possibleQuantities = plainNumbers
                                  .map((num: string) => parseInt(num, 10))
                                  .filter((num: number) => num >= 10 && num <= 10000);
                                  
                                if (possibleQuantities.length > 0) {
                                  // Use the first number in our range
                                  quantityMatch = ['', possibleQuantities[0].toString()];
                                  console.log(`[Email Extraction] Found quantity from plain number in fallback: ${quantityMatch[1]}`);
                                }
                              }
                            }
                            
                            if (quantityMatch && quantityMatch[1]) {
                              quantity = parseInt(quantityMatch[1].trim(), 10);
                              console.log(`[Email Extraction] Extracted Quantity with subject fallback: ${quantity}`);
                            }
                            
                            // Create the order data object with subject ID fallback
                            emailData.orderData = {
                              orderId: emailData.orderId,
                              url: url,
                              quantity: quantity,
                              processed: true,
                              source: 'email-subject-fallback'
                            };
                            console.log(`[Email Extraction] Created order data using subject fallback: ${JSON.stringify(emailData.orderData)}`);
                          } else {
                            console.log(`[Email Extraction] Could not extract URL even with subject fallback`);
                          }
                        }
                      }
                    });
                  }
                });
              });

              msg.once('attributes', (attrs) => {
                emailData.uid = attrs.uid;
                
                // Extract date from internal date attribute
                if (attrs.date) {
                  emailData.date = new Date(attrs.date);
                } else if (attrs.internaldate) {
                  emailData.date = new Date(attrs.internaldate);
                }
              });

              msg.once('end', () => {
                processedEmails.push(emailData);
              });
            });

            fetch.once('error', (err: Error) => {
              connectionError = err;
              console.error('Fetch error:', err);
            });

            fetch.once('end', async () => {
              // After processing all emails, open mailbox in readwrite mode to mark emails
              try {
                // Get latest config with custom email age limit
                const latestConfig = getEmailConfig();
                
                // Only filter by date if the setting is enabled
                if (latestConfig.limitEmailAge) {
                  // Calculate date cutoff based on settings (default 10 days)
                  const maxAgeMinutes = latestConfig.maxEmailAgeMinutes || 14400; // Default 10 days (14400 minutes)
                  const cutoffDate = new Date();
                  cutoffDate.setMinutes(cutoffDate.getMinutes() - maxAgeMinutes);
                  
                  console.log(`[Email Processing] Filtering emails with date limit of ${maxAgeMinutes} minutes (${Math.round(maxAgeMinutes/1440 * 10) / 10} days)`);
                  
                  // Log the cutoff date in a user-friendly format
                  console.log(`[Email Processing] Only processing emails received since ${cutoffDate.toISOString()}`);
                  
                  // Filter emails to only process those newer than the cutoff date
                  const filteredEmails = processedEmails.filter(email => {
                    // If we don't have date information, skip the email (safety check)
                    if (!email.date) {
                      console.log(`[Email Processing] Skipping email with no date information`);
                      return false;
                    }
                    
                    // Log the date comparisons for debugging
                    const isNewerThanCutoff = email.date > cutoffDate;
                    if (!isNewerThanCutoff) {
                      console.log(`[Email Processing] Skipping email from ${email.date.toISOString()} - older than cutoff`);
                    }
                    
                    // Only keep emails newer than cutoff date
                    return isNewerThanCutoff;
                  });
                  
                  // Replace processedEmails with filtered list
                  processedEmails = filteredEmails;
                  
                  console.log(`[Email Processing] Filtered to ${processedEmails.length} emails from the last ${Math.round(maxAgeMinutes/1440 * 10) / 10} days (${maxAgeMinutes} minutes)`);
                } else {
                  console.log(`[Email Processing] Email age filtering is disabled, processing all ${processedEmails.length} emails`);
                }
                
                // Close the readonly box
                imap.closeBox((err) => {
                  if (err) console.error('Error closing box:', err);
                  
                  // Open the box in readwrite mode
                  imap.openBox('INBOX', false, async (err, box) => {
                    if (err) {
                      console.error('Error opening inbox in readwrite mode:', err);
                      imap.end();
                      return res.status(500).json({ success: false, message: 'Failed to open inbox for marking emails', error: err.message });
                    }
                    
                    // Process emails and add URLs to campaign
                    for (const email of processedEmails) {
                      // Only process whitelisted emails with valid order data
                      if (email.isWhitelisted && email.orderData && email.orderData.processed) {
                        try {
                          // Add URL to campaign
                          const { orderId, url, quantity } = email.orderData;
                          
                          // OPTIMIZATION: Use memory-efficient check function for millions of records
                          // This function combines caching and selective database queries for minimal overhead
                          const { exists: orderExists, source: existenceSource } = await checkProcessedOrderEfficient(orderId);
                          
                          // Use compact logging to reduce log size with millions of entries
                          const timestamp = new Date().toISOString();
                          console.log(`[ORDER_CHECK][${timestamp}] Campaign: ${campaignId}, Order: ${orderId}, Exists: ${orderExists ? 'YES' : 'NO'}, Source: ${existenceSource || 'N/A'}`);
                          
                          // Add to campaign processing log table (if it existed)
                          // For now, just detailed console logging
                          
                          // Also check if the campaign is active
                          const targetCampaign = await db.query.redirectCampaigns.findFirst({
                            where: and(
                              eq(redirectCampaigns.id, campaignId),
                              eq(redirectCampaigns.isArchived, false)
                            )
                          });
                          
                          if (!targetCampaign) {
                            console.log(`Campaign ID ${campaignId} is deleted or archived, skipping URL addition for order ${orderId}`);
                            
                            // Click multiplier feature has been removed
                            let originalQuantity = quantity;
                            
                            // Store the URL with rejected status in the database
                            try {
                              await db.insert(redirectUrls).values({
                                campaignId: campaignId,
                                name: orderId,
                                url: url,
                                status: 'rejected', // Mark it as rejected
                                clickLimit: originalQuantity,
                                weight: 0  // Weight 0 so it won't be used
                              });
                              console.log(`Stored rejected URL for order ${orderId} with reason 'Campaign deleted or archived'`);
                            } catch (insertError) {
                              console.error(`Error storing rejected URL for order ${orderId}:`, insertError);
                            }
                            
                            addedUrls.push({
                              orderId,
                              url,
                              quantity,
                              added: false,
                              reason: 'Campaign deleted or archived'
                            });
                            
                            // Mark email as seen even if we didn't add it - we processed it
                            imap.setFlags([email.uid], ['\\Seen'], (err: any) => {
                              if (err) console.error(`Error marking email ${email.uid} as read:`, err);
                            });
                          }
                          // Check if Order ID already exists to prevent duplicates
                          // using our memory-efficient optimized function
                          else if (orderExists) {
                            const reason = `Order ID '${orderId}' found in ${existenceSource} - DUPLICATE BLOCK`;
                            const rejectTimestamp = new Date().toISOString();
                            console.log(`[DUPLICATE_ORDER][${rejectTimestamp}] Campaign: ${campaignId}, Order ID: ${orderId}, URL: ${url}, Quantity: ${quantity}, Status: rejected, Source: ${existenceSource}`);
                            
                            // Only try to log to processed_orders if it wasn't found there
                            // This avoids duplicate key errors when source is processed_orders_history or memory_cache
                            if (existenceSource !== 'processed_orders_history' && existenceSource !== 'memory_cache') {
                              try {
                                // Click multiplier feature has been removed
                                let originalQuantity = quantity;
                                let multipliedQuantity = originalQuantity;
                                
                                await db.insert(processedOrders).values({
                                  orderId: orderId,
                                  url: url,
                                  landingName: orderId,
                                  quantity: multipliedQuantity, // Store multiplied quantity for consistency
                                  campaignId: campaignId,
                                  campaignName: targetCampaign.name,
                                  status: 'rejected',
                                  source: 'email',
                                  processed: false,
                                  duplicateCheck: true,
                                  notes: `Duplicate order detected at ${rejectTimestamp}, source: ${existenceSource} - Quantity: ${originalQuantity}`
                                });
                                console.log(`[PROCESSED_ORDERS_LOG] Added record for duplicate order ${orderId}`);
                              } catch (error) {
                                // Only log real errors, ignore constraint violations (which are expected)
                                const logError = error as Error;
                                if (!logError.message?.includes('duplicate key value')) {
                                  console.error(`Error logging rejected order:`, logError);
                                }
                              }
                            } else {
                              console.log(`[PROCESSED_ORDERS_LOG] Order ${orderId} already exists in processed_orders, skipping insertion`);
                            }
                            
                            addedUrls.push({
                              orderId,
                              url,
                              quantity,
                              added: false,
                              reason: reason
                            });
                            
                            // Mark email as seen
                            imap.setFlags([email.uid], ['\\Seen'], (err: any) => {
                              if (err) console.error(`Error marking email ${email.uid} as read:`, err);
                            });
                          } 
                          else {
                            try {
                              // Click multiplier feature has been removed
                              const originalQuantity = quantity;
                              const multipliedQuantity = originalQuantity;
                              
                              console.log(`[Email Processing] Processing order with quantity ${originalQuantity}`);
                              
                              // URL doesn't exist and campaign is active - proceed with adding
                              // Create URL using only fields defined in insertRedirectUrlSchema
                              const insertResult = await db.insert(redirectUrls).values({
                                campaignId: campaignId,
                                name: orderId,
                                url: url,
                                status: 'active',
                                clickLimit: multipliedQuantity, // Store the multiplied quantity as the click limit
                                weight: originalQuantity // Keep original quantity for weight calculation
                                // These fields are omitted in insertRedirectUrlSchema:
                                // - id (auto-generated)
                                // - clicks (defaults to 0)
                                // - createdAt (defaults to current timestamp)
                                // - lastServed (defaults to null)
                              });
                              
                              // Get the inserted redirect URL for its ID
                              const insertedUrl = await db.query.redirectUrls.findFirst({
                                where: eq(redirectUrls.name, orderId)
                              });
                              
                              // Also add to the permanent processed orders log
                              await db.insert(processedOrders).values({
                                orderId: orderId,
                                url: url,
                                landingName: orderId,
                                quantity: multipliedQuantity, // Store multiplied quantity in processed orders to be consistent
                                campaignId: campaignId,
                                campaignName: targetCampaign.name,
                                urlId: insertedUrl ? insertedUrl.id : undefined,
                                status: 'processed',
                                source: 'email',
                                processed: true,
                                duplicateCheck: false,
                                notes: `Added from email processing at ${new Date().toISOString()} - Quantity: ${originalQuantity}`
                              });
                              
                              // IMPORTANT: Add to memory cache for immediate duplicate detection
                              // This ensures that even if another request comes in right after this one,
                              // before the database has time to commit, we'll still detect the duplicate
                              processedOrdersCache.set(orderId, true);
                              console.log(`[Cache] Added order ID ${orderId} to memory cache for immediate duplicate detection`);
                              
                              const addTimestamp = new Date().toISOString();
                              console.log(`[URL_ADDED][${addTimestamp}] Campaign: ${campaignId}, Order ID: ${orderId}, URL: ${url}, Quantity: ${quantity}, Added: success, Permanent record created in processedOrders table`);
                              
                              // Invalidate campaign cache in the redirector controller
                              // We need to import the cache from the redirector controller
                              try {
                                // Get the NodeCache from redirector module
                                // Use dynamic import to get the caches
                                const redirectorModule = await import('../controllers/redirector');
                                
                                // Invalidate the campaign's URLs cache
                                if (redirectorModule.campaignCache && typeof redirectorModule.campaignCache.del === 'function') {
                                  redirectorModule.campaignCache.del(`campaign:${campaignId}:urls`);
                                  console.log(`Invalidated cache for campaign ${campaignId}`);
                                }
                              } catch (cacheError) {
                                console.error('Failed to invalidate cache:', cacheError);
                              }
                              
                              // Mark email as successfully processed 
                              email.successfullyProcessed = true;
                              
                              addedUrls.push({
                                orderId,
                                url,
                                quantity,
                                added: true
                              });
                            } catch (error) {
                              const insertError = error as Error;
                              console.error(`Error adding URL for order ${orderId}:`, insertError);
                              
                              // Check if it's a duplicate name error
                              let errorReason = 'Database error';
                              if (insertError.message && insertError.message.includes('duplicate')) {
                                errorReason = 'Duplicate name';
                              }
                              
                              // Store the URL with rejected status
                              try {
                                // Click multiplier feature has been removed
                                let originalQuantity = quantity;
                                let multipliedQuantity = originalQuantity;
                                
                                console.log(`[Email Processing] Processing rejected URL with quantity ${originalQuantity}`);
                                
                                await db.insert(redirectUrls).values({
                                  campaignId: campaignId,
                                  name: `${orderId}_rejected`, // Add suffix to make unique
                                  url: url,
                                  status: 'rejected', // Mark it as rejected
                                  clickLimit: multipliedQuantity, // Use multiplied quantity as the click limit
                                  weight: 0  // Weight 0 so it won't be used
                                });
                                console.log(`Stored rejected URL for order ${orderId} with reason '${errorReason}'`);
                              } catch (storeError) {
                                console.error(`Error storing rejected URL for order ${orderId}:`, storeError);
                              }
                              
                              addedUrls.push({
                                orderId,
                                url,
                                quantity,
                                added: false,
                                reason: errorReason
                              });
                            }
                            
                            // Mark email as seen
                            imap.setFlags([email.uid], ['\\Seen'], (err: any) => {
                              if (err) console.error(`Error marking email ${email.uid} as read:`, err);
                            });
                          }
                        } catch (error) {
                          console.error(`Error processing email ${email.id}:`, error);
                        }
                      }
                    }
                    
                    // Get latest config for auto-delete feature
                    const finalConfig = getEmailConfig();
                    
                    // Auto-delete emails if the setting is enabled
                    if (finalConfig.autoDeleteEmails && processedEmails.length > 0) {
                      try {
                        console.log(`[Email Auto-Delete] Auto-delete is enabled with deleteAfterMinutes: ${finalConfig.deleteAfterMinutes}`);
                        
                        // Calculate the auto-delete cutoff time based on settings
                        const deleteAfterMinutes = finalConfig.deleteAfterMinutes || 1440; // Default to 24 hours if not set
                        const deleteTimeCutoff = new Date();
                        deleteTimeCutoff.setMinutes(deleteTimeCutoff.getMinutes() - deleteAfterMinutes);
                        
                        console.log(`[Email Auto-Delete] Will delete processed emails older than ${deleteAfterMinutes} minutes (${Math.round(deleteAfterMinutes/60 * 10) / 10} hours)`);
                        console.log(`[Email Auto-Delete] Delete cutoff time: ${deleteTimeCutoff.toISOString()}`);
                        
                        // Get UIDs ONLY from SUCCESSFULLY processed emails
                        // We'll only delete emails that:
                        // 1. Are from whitelisted senders
                        // 2. Have successfully extracted order data
                        // 3. Meet our processing requirements
                        // 4. Were marked as successfully processed (URL was added to campaign)
                        // 5. Are older than the deleteAfterMinutes setting
                        const emailUids = processedEmails
                          .filter(email => 
                            email.uid && 
                            email.isWhitelisted && 
                            email.orderData && 
                            email.orderData.processed && 
                            email.successfullyProcessed === true &&
                            email.date && new Date(email.date) < deleteTimeCutoff // Only delete emails older than our cutoff
                          ) 
                          .map(email => email.uid);
                          
                        console.log(`[Email Auto-Delete] Found ${emailUids.length} out of ${processedEmails.length} emails that qualify for deletion (older than ${deleteAfterMinutes} minutes)`);
                          
                        if (emailUids.length > 0) {
                          console.log(`[Email Auto-Delete] Deleting ${emailUids.length} processed emails as per settings`);
                          
                          // Add the Delete flag to emails to move them to Trash
                          imap.addFlags(emailUids, '\\Deleted', (err) => {
                            if (err) {
                              console.error(`[Email Auto-Delete] Error flagging emails for deletion:`, err);
                            } else {
                              // Expunge to permanently remove the emails
                              imap.expunge((expungeErr) => {
                                if (expungeErr) {
                                  console.error(`[Email Auto-Delete] Error expunging deleted emails:`, expungeErr);
                                } else {
                                  console.log(`[Email Auto-Delete] Successfully deleted ${emailUids.length} emails`);
                                }
                                
                                // Close connection after deletion attempt
                                imap.end();
                              });
                              return; // Return early to avoid closing connection before expunge completes
                            }
                            
                            // Close connection if addFlags failed
                            imap.end();
                          });
                          return; // Return early to avoid closing connection before addFlags completes
                        } else {
                          console.log(`[Email Auto-Delete] No valid email UIDs found for deletion`);
                        }
                      } catch (deleteError) {
                        console.error(`[Email Auto-Delete] Error during email deletion:`, deleteError);
                      }
                    } else {
                      console.log(`[Email Auto-Delete] Auto-delete is disabled, skipping deletion`);
                    }
                    
                    // Close connection if not auto-deleting
                    imap.end();
                    
                    return res.json({
                      success: true,
                      message: `Processed ${processedEmails.length} emails, added ${addedUrls.length} URLs to campaign`,
                      processed: processedEmails.length,
                      added: addedUrls.length,
                      urls: addedUrls
                    });
                  });
                });
              } catch (error) {
                console.error('Error in closing/opening box:', error);
                imap.end();
                return res.status(500).json({ 
                  success: false, 
                  message: 'Error processing emails', 
                  error: error instanceof Error ? error.message : String(error) 
                });
              }
            });
          });
        });
      } catch (error) {
        imap.end();
        console.error('Error in IMAP processing:', error);
        return res.status(500).json({ 
          success: false, 
          message: 'Error in IMAP processing', 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    });

    imap.once('error', (err: any) => {
      connectionError = err;
      console.error('IMAP connection error:', err);
      
      // Format a more user-friendly error message
      let errorMessage = 'IMAP connection error';
      let errorStatus = 500;
      
      // Check for quota exceeded errors
      if (err.message && (err.message.includes('OVERQUOTA') || err.message.includes('exceeded'))) {
        errorMessage = 'Gmail account has exceeded its quota or rate limits. Please wait a few minutes before trying again. The email processing system will automatically retry.';
        errorStatus = 429; // Too many requests
        
        // For quota errors during auto-check, we just log and don't return an error
        if (req.query.source === 'auto') {
          console.log('[Email Processing] Quota exceeded, will retry later automatically');
          return;
        }
      }
      
      if (!res.headersSent) {
        return res.status(errorStatus).json({ 
          success: false, 
          message: errorMessage, 
          error: err?.message || String(err) 
        });
      }
    });
    
    // Also watch for BYE events which can include quota issues
    imap.once('close', (hadError: boolean) => {
      if (hadError && !res.headersSent && connectionError === null) {
        console.error('IMAP connection closed unexpectedly with an error during email processing');
        
        // Only send response if this is a manual check, not an auto-check
        if (req.query.source !== 'auto') {
          return res.status(500).json({
            success: false,
            message: 'Gmail connection closed unexpectedly. This can happen when the account exceeds its quota or rate limits. The system will automatically retry later.',
          });
        }
      }
    });

    imap.connect();

  } catch (error: unknown) {
    console.error('Failed to process emails:', error);
    return res.status(500).json({ 
      success: false, 
      message: 'Failed to process emails', 
      error: error instanceof Error ? error.message : String(error) 
    });
  }
}

// Variables to track email processor state for improved stability
let emailProcessorRunning = false;
let emailProcessorTimer: NodeJS.Timeout | null = null;
let consecutiveErrors = 0;
const MAX_CONSECUTIVE_ERRORS = 5;

// Function to run automatic email checking at intervals with improved stability
export function setupEmailAutoProcessing() {
  // Cleanup any existing timers to prevent duplication
  if (emailProcessorTimer) {
    clearTimeout(emailProcessorTimer);
    emailProcessorTimer = null;
  }
  
  // Reset error tracking
  consecutiveErrors = 0;
  emailProcessorRunning = false;
  
  console.log('Setting up email processing with improved stability (1-minute intervals)');
  
  // Schedule first check with short delay
  scheduleNextEmailCheck(5000);
}

// Schedule next email check with proper error handling
function scheduleNextEmailCheck(delay = 60000) {
  // Cleanup any existing timer
  if (emailProcessorTimer) {
    clearTimeout(emailProcessorTimer);
  }
  
  // Create new timer
  emailProcessorTimer = setTimeout(() => {
    // Only run if not already running
    if (!emailProcessorRunning) {
      // Execute check and properly schedule next run
      runEmailCheck()
        .catch(err => {
          console.error('[Email Processor] Error during check:', err.message);
          consecutiveErrors++;
        })
        .finally(() => {
          // Schedule next run with appropriate delay
          const nextDelay = getNextCheckDelay();
          scheduleNextEmailCheck(nextDelay);
        });
    } else {
      console.log('[Email Processor] Previous check still running, skipping this cycle');
      // Still schedule next run
      const nextDelay = getNextCheckDelay();
      scheduleNextEmailCheck(nextDelay);
    }
  }, delay);
  
  console.log(`[Email Processor] Next check scheduled in ${Math.round(delay/1000)} seconds`);
}

// Calculate next check delay based on error history
function getNextCheckDelay() {
  const BASE_INTERVAL = 60 * 1000; // 1 minute
  
  if (consecutiveErrors > 0) {
    // Exponential backoff for errors
    const backoffFactor = Math.min(consecutiveErrors, MAX_CONSECUTIVE_ERRORS);
    const backoffDelay = BASE_INTERVAL * Math.pow(2, backoffFactor);
    const maxDelay = 15 * 60 * 1000; // Max 15 minutes
    
    console.log(`[Email Processor] Using backoff delay after ${consecutiveErrors} errors: ${Math.round(backoffDelay/1000)} seconds`);
    
    return Math.min(backoffDelay, maxDelay);
  }
  
  return BASE_INTERVAL;
}

// Separate function to run the email check process with proper resource management
async function runEmailCheck() {
  // Set running flag to prevent overlapping runs
  if (emailProcessorRunning) {
    console.log('[Email Processor] Already running, skipping this cycle');
    return;
  }
  
  // Mark as running and set up a safety timeout
  emailProcessorRunning = true;
  const safetyTimeout = setTimeout(() => {
    console.error('[Email Processor] Safety timeout triggered after 3 minutes');
    // Force cleanup
    emailProcessorRunning = false;
    consecutiveErrors++;
  }, 3 * 60 * 1000);
  
  try {
    console.log(`[${new Date().toISOString()}] Running automatic email check...`);
    
    // Create a promise-based version of our process to properly handle timeouts
    return await new Promise<void>((resolve, reject) => {
      // Create a fake request and response object to reuse our processNewEmails function
      const fakeReq = {
        query: { source: 'auto' }, // Mark this as an automatic check
        // Add minimal required properties for Request object
        get: () => {},
        header: () => {},
        headers: {},
        body: {},
        params: {},
        session: {},
        ip: ''
      } as unknown as Request;
      
      const fakeRes = {
        status: (code: number) => ({
          json: (data: any) => {
            if (code !== 200) {
              console.error(`[${new Date().toISOString()}] Auto email process error:`, data);
              // Log error
              logEmailProcessingResult(false, data);
              reject(new Error(`Email processing failed with status ${code}: ${data.message || 'Unknown error'}`));
            } else {
              console.log(`[${new Date().toISOString()}] Auto email process result:`, data);
              // Log successful processing
              logEmailProcessingResult(true, data);
              // Reset error counter on success
              consecutiveErrors = 0;
              resolve();
            }
          }
        }),
        json: (data: any) => {
          console.log(`[${new Date().toISOString()}] Auto email process result:`, data);
          // Log successful processing
          logEmailProcessingResult(true, data);
          // Reset error counter on success
          consecutiveErrors = 0;
          resolve();
        }
      } as unknown as Response;
      
      // Process emails with proper error handling
      processNewEmails(fakeReq, fakeRes).catch(err => {
        console.error(`[${new Date().toISOString()}] Error in email processing:`, err);
        logEmailProcessingResult(false, { error: err instanceof Error ? err.message : String(err) });
        reject(err);
      });
    });
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error in automatic email processing:`, error);
    // Log error
    logEmailProcessingResult(false, { error: error instanceof Error ? error.message : String(error) });
    // Track error for backoff
    consecutiveErrors++;
    throw error;
  } finally {
    // Always clear timeout and reset running state
    clearTimeout(safetyTimeout);
    emailProcessorRunning = false;
  }
}

// Log email processing results with memory optimization to handle millions of landers
function logEmailProcessingResult(success: boolean, data: any) {
  const timestamp = new Date().toISOString();
  const logPrefix = success ? 'EMAIL_PROCESS_SUCCESS' : 'EMAIL_PROCESS_ERROR';
  
  // Format URLs processed for better readability, but limit the output for memory efficiency
  let urlsInfo = '';
  if (success && data.urls && Array.isArray(data.urls)) {
    // Only show a summary count if there are more than 10 URLs to save memory
    if (data.urls.length > 10) {
      const addedCount = data.urls.filter((url: any) => url.added).length;
      const rejectedCount = data.urls.length - addedCount;
      urlsInfo = `\n    Summary: ${addedCount} URLs added, ${rejectedCount} URLs rejected (showing first 5)`;
      
      // Only show details for the first 5 URLs
      urlsInfo += data.urls.slice(0, 5).map((url: any) => 
        `\n    - Order: ${url.orderId}, URL: ${url.url.substring(0, 30)}${url.url.length > 30 ? '...' : ''}, Quantity: ${url.quantity}, Added: ${url.added}`
      ).join('');
    } else {
      // For smaller lists, show all but truncate long URLs
      urlsInfo = data.urls.map((url: any) => 
        `\n    - Order: ${url.orderId}, URL: ${url.url.substring(0, 30)}${url.url.length > 30 ? '...' : ''}, Quantity: ${url.quantity}, Added: ${url.added}`
      ).join('');
    }
  }
  
  // Get memory usage stats to monitor efficiency 
  const memoryUsage = process.memoryUsage();
  const memoryInfo = `\n    Memory: ${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB used / ${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB allocated`;
  
  // Cache stats for monitoring
  const stats = processedOrdersCache.getStats();
  const cacheInfo = `\n    Cache: ${stats.keys} order IDs cached, Hits: ${stats.hits}, Misses: ${stats.misses}`;
  
  // For database logging, we could insert this into a dedicated email_process_logs table
  // For now, structured console logging will have to do
  console.log(`[${logPrefix}][${timestamp}] Processed: ${data.processed || 0}, Added: ${data.added || 0}${urlsInfo}${memoryInfo}${cacheInfo}`);
}

// Function to start auto-processing
export function startAutoEmailProcessing() {
  setupEmailAutoProcessing();
}