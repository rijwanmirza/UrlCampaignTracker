      break;

        case "http_307":
          // HTTP 307 Temporary Redirect
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);
          res.status(307).header("Location", targetUrl).end();
          break;

        case "http2_307_temporary":
          // HTTP/2.0 307 Temporary Redirect (matching viralplayer.xyz implementation)
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);

          // Note: True HTTP/2.0 requires HTTPS in production
          // These headers help indicate HTTP/2.0 intention
          res.setHeader("X-HTTP2-Version", "HTTP/2.0");
          res.setHeader("Alt-Svc", "h2=\":443\"; ma=86400");
          res.setHeader("X-Protocol-Version", "h2");

          // Add standard headers used by HTTP/2 servers
          res.setHeader("Cache-Control", "no-cache");
          res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");

          // Add server identification to match pattern
          res.setHeader("X-Powered-By", "ViralEngine/2.0");

          // Send 307 redirect with HTTP/2 mimicking headers
          res.status(307).header("Location", targetUrl).end();
          break;

        case "http2_forced_307":
          // This implementation matches the exact format seen in viralplayer.xyz
          // First, set all headers exactly in the same order as the reference implementation

          // Create a set-cookie that matches reference implementation format
          const cookieExpiration = new Date();
          cookieExpiration.setFullYear(cookieExpiration.getFullYear() + 1); // Expire in 1 year
          const cookieExpiryString = cookieExpiration.toUTCString();

          // Generate a random ID similar to viralplayer.xyz
          const randomId = Math.random().toString(16).substring(2, 10);

          // Set headers exactly matching viralplayer.xyz in their specific order
          res.removeHeader('X-Powered-By'); // Clear default Express headers
          res.setHeader("date", new Date().toUTCString());
          res.setHeader("content-length", "0");
          res.setHeader("location", targetUrl);
          res.setHeader("server", "cloudflare");

          // Generate a UUID for x-request-id
          const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
          res.setHeader("x-request-id", uuid);

          res.setHeader("cf-cache-status", "DYNAMIC");

          // Set cookies that match the format
          res.setHeader("set-cookie", [
            `bc45=fpc0|${randomId}::351:55209; SameSite=Lax; Max-Age=31536000; Expires=${cookieExpiryString}`,
            `rc45=fpc0|${randomId}::28; SameSite=Lax; Max-Age=31536000; Expires=${cookieExpiryString}`,
            `uclick=mr7ZxwtaaNs1gOWlamCY4hIUD7craeFLJuyMJz3hmBMFe4/9c70RDu5SgPFmEHXMW9DJfw==; SameSite=Lax; Max-Age=31536000`,
            `bcid=d0505amc402c73djlgl0; SameSite=Lax; Max-Age=31536000`
          ]);

          // Generate a random CF-Ray value
          const cfRay = Math.random().toString(16).substring(2, 11) + "a3fe-EWR";
          res.setHeader("cf-ray", cfRay);

          // Alt-Svc header for HTTP/3 protocol negotiation
          res.setHeader("alt-svc", "h3=\":443\"; ma=86400");

          // Send 307 redirect
          res.status(307).end();
          break;

        case "direct":
        default:
          // Standard redirect (302 Found)
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);
          res.redirect(targetUrl);
          break;
      }
    } catch (error) {
      res.status(500).json({ message: "Redirect failed" });
    }
  });

  // High-performance campaign URL with optimized weighted distribution
  app.get("/c/:campaignId", async (req: Request, res: Response) => {
    try {
      const startTime = process.hrtime();
      const campaignId = parseInt(req.params.campaignId);

      if (isNaN(campaignId)) {
        return res.status(400).json({ message: "Invalid campaign ID" });
      }

      console.log(`Processing campaign ID: ${campaignId}`);

      // Get the campaign to check if it exists - use fresh data
      const campaign = await storage.getCampaign(campaignId);
      if (!campaign) {
        console.log(`Campaign not found for ID: ${campaignId}`);
        return res.status(404).json({ message: "Campaign not found" });
      }

      console.log(`Found campaign ID ${campaign.id}`);
      console.log(`Campaign has ${campaign.urls.length} total URLs`);
      console.log(`Campaign has ${campaign.urls.filter(url => url.isActive).length} active URLs`);

      // Use our optimized method to get a URL based on weighted distribution
      const selectedUrl = await storage.getRandomWeightedUrl(campaignId);

      // If no active URLs are available, show an error
      if (!selectedUrl) {
        console.log(`No active URLs available for campaign ID ${campaignId}`);
        return res.status(410).json({ message: "All URLs in this campaign have reached their click limits" });
      }

      console.log(`Selected URL ID ${selectedUrl.id} (${selectedUrl.name}) for redirect`);

      // Redirect to the specific URL directly without going through the /r/ endpoint
      // This saves an extra HTTP redirect and improves performance

      // Increment click count first
      await storage.incrementUrlClicks(selectedUrl.id);

      // Performance metrics
      const endTime = process.hrtime(startTime);
      const timeInMs = (endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2);

      // Handle the redirect based on the campaign's redirect method
      const targetUrl = selectedUrl.targetUrl;

      switch (campaign.redirectMethod) {
        case "meta_refresh":
          // Meta refresh redirect - completely invisible
          res.send(`
            <!DOCTYPE html>
            <html>
              <head>
                <meta http-equiv="refresh" content="0;url=${targetUrl}">
                <title></title>
                <style>body{display:none}</style>
              </head>
              <body></body>
            </html>
          `);
          break;

        case "double_meta_refresh":
          // For double meta refresh - completely invisible
          res.send(`
            <!DOCTYPE html>
            <html>
              <head>
                <meta http-equiv="refresh" content="0;url=${targetUrl}">
                <title></title>
                <style>body{display:none}</style>
                <script>
                  // Immediate redirect without any visible elements
                  window.location.href = "${targetUrl}";
                </script>
              </head>
              <body></body>
            </html>
          `);
          break;

        case "http_307":
          // HTTP 307 Temporary Redirect
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);
          res.status(307).header("Location", targetUrl).end();
          break;

        case "http2_307_temporary":
          // HTTP/2.0 307 Temporary Redirect (matching viralplayer.xyz implementation)
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);

          // Note: True HTTP/2.0 requires HTTPS in production
          // These headers help indicate HTTP/2.0 intention
          res.setHeader("X-HTTP2-Version", "HTTP/2.0");
          res.setHeader("Alt-Svc", "h2=\":443\"; ma=86400");
          res.setHeader("X-Protocol-Version", "h2");

          // Add standard headers used by HTTP/2 servers
          res.setHeader("Cache-Control", "no-cache");
          res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");

          // Add server identification to match pattern
          res.setHeader("X-Powered-By", "ViralEngine/2.0");

          // Send 307 redirect with HTTP/2 mimicking headers
          res.status(307).header("Location", targetUrl).end();
          break;

        case "http2_forced_307":
          // This implementation matches the exact format seen in viralplayer.xyz
          // First, set all headers exactly in the same order as the reference implementation

          // Create a set-cookie that matches reference implementation format
          const cookieExpiration = new Date();
          cookieExpiration.setFullYear(cookieExpiration.getFullYear() + 1); // Expire in 1 year
          const cookieExpiryString = cookieExpiration.toUTCString();

          // Generate a random ID similar to viralplayer.xyz
          const randomId = Math.random().toString(16).substring(2, 10);

          // Set headers exactly matching viralplayer.xyz in their specific order
          res.removeHeader('X-Powered-By'); // Clear default Express headers
          res.setHeader("date", new Date().toUTCString());
          res.setHeader("content-length", "0");
          res.setHeader("location", targetUrl);
          res.setHeader("server", "cloudflare");

          // Generate a UUID for x-request-id
          const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
          res.setHeader("x-request-id", uuid);

          res.setHeader("cf-cache-status", "DYNAMIC");

          // Set cookies that match the format
          res.setHeader("set-cookie", [
            `bc45=fpc0|${randomId}::351:55209; SameSite=Lax; Max-Age=31536000; Expires=${cookieExpiryString}`,
            `rc45=fpc0|${randomId}::28; SameSite=Lax; Max-Age=31536000; Expires=${cookieExpiryString}`,
            `uclick=mr7ZxwtaaNs1gOWlamCY4hIUD7craeFLJuyMJz3hmBMFe4/9c70RDu5SgPFmEHXMW9DJfw==; SameSite=Lax; Max-Age=31536000`,
            `bcid=d0505amc402c73djlgl0; SameSite=Lax; Max-Age=31536000`
          ]);

          // Generate a random CF-Ray value
          const cfRay = Math.random().toString(16).substring(2, 11) + "a3fe-EWR";
          res.setHeader("cf-ray", cfRay);

          // Alt-Svc header for HTTP/3 protocol negotiation
          res.setHeader("alt-svc", "h3=\":443\"; ma=86400");

          // Send 307 redirect
          res.status(307).end();
          break;

        case "direct":
        default:
          // Standard redirect (302 Found)
          res.setHeader("X-Processing-Time", `${timeInMs}ms`);
          res.redirect(targetUrl);
          break;
      }
    } catch (error) {
      res.status(500).json({ message: "Redirect failed" });
    }
  });

  // Gmail Reader API endpoints
  const gmailConfigSchema = z.object({
    user: z.string().email(),
    password: z.string().min(1),
    host: z.string().default('imap.gmail.com'),
    port: z.number().int().positive().default(993),
    tls: z.boolean().default(true),
    tlsOptions: z.object({
      rejectUnauthorized: z.boolean()
    }).optional().default({ rejectUnauthorized: false }),
    whitelistSenders: z.array(z.string()).default([]),
    subjectPattern: z.string(),
    messagePattern: z.object({
      orderIdRegex: z.string(),
      urlRegex: z.string(),
      quantityRegex: z.string()
    }),
    defaultCampaignId: z.number().int().positive(),
    checkInterval: z.number().int().positive().default(60000),
    // Make sure auto-delete minutes is properly typed and validated
    autoDeleteMinutes: z.number().int().nonnegative().default(0).transform(val =>
      // Explicitly convert to number to handle string values from form submissions
      typeof val === 'string' ? parseInt(val, 10) : val
    )
  });

  // Get Gmail reader status
  app.get("/api/gmail-reader/status", (_req: Request, res: Response) => {
    try {
      const status = gmailReader.getStatus();

      // Make sure autoDeleteMinutes is explicitly included (in case it's undefined or not set)
      if (status.config && typeof status.config.autoDeleteMinutes !== 'number') {
        status.config.autoDeleteMinutes = 0; // Default value if not set
      }

      console.log('🔍 DEBUG: Returning Gmail status with autoDeleteMinutes:',
                  status.config?.autoDeleteMinutes);

      res.json(status);
    } catch (error) {
      res.status(500).json({
        message: "Failed to get Gmail reader status",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Configure Gmail reader
  app.post("/api/gmail-reader/config", async (req: Request, res: Response) => {
    try {
      // Convert string regex to RegExp objects
      const rawConfig = req.body;

      // Parse the input with basic validation
      const result = gmailConfigSchema.safeParse(rawConfig);

      if (!result.success) {
        const validationError = fromZodError(result.error);
        return res.status(400).json({ message: validationError.message });
      }

      // Convert string patterns to RegExp objects
      const config = {
        ...result.data,
        subjectPattern: new RegExp(result.data.subjectPattern),
        messagePattern: {
          orderIdRegex: new RegExp(result.data.messagePattern.orderIdRegex),
          urlRegex: new RegExp(result.data.messagePattern.urlRegex),
          quantityRegex: new RegExp(result.data.messagePattern.quantityRegex)
        },
        // Ensure autoDeleteMinutes is explicitly set (and default to 0 if undefined)
        autoDeleteMinutes: typeof result.data.autoDeleteMinutes === 'number'
          ? result.data.autoDeleteMinutes
          : 0
      };

      console.log('🔍 DEBUG: Updating Gmail config with autoDeleteMinutes:', config.autoDeleteMinutes);

      // Check if the campaign exists
      const campaign = await storage.getCampaign(config.defaultCampaignId);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found for defaultCampaignId" });
      }

      // Update the Gmail reader configuration
      const updatedConfig = gmailReader.updateConfig(config);

      res.json({
        message: "Gmail reader configuration updated successfully",
        config: {
          ...updatedConfig,
          password: "******" // Hide password in response
        }
      });
    } catch (error) {
      res.status(500).json({
        message: "Failed to configure Gmail reader",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Test Gmail connection (using both SMTP and IMAP methods)
  app.post("/api/gmail-reader/test-connection", async (req: Request, res: Response) => {
    try {
      const { user, password, host = 'imap.gmail.com', port = 993, tls = true } = req.body;

      if (!user || !password) {
        return res.status(400).json({
          success: false,
          message: "Missing credentials. Please provide user and password."
        });
      }

      // First try SMTP verification (often more reliable with Gmail)
      // Get the current config to preserve important settings like autoDeleteMinutes
      const currentConfig = gmailReader.getStatus().config;

      // Create a temporary config that preserves important settings
      const tempConfig = {
        user,
        password,
        host,
        port,
        tls,
        whitelistSenders: ['help@donot-reply.in'], // Include the requested whitelist
        autoDeleteMinutes: currentConfig?.autoDeleteMinutes || 0 // Preserve auto-delete setting
      };

      // Update the main Gmail reader with the credentials for testing
      gmailReader.updateConfig(tempConfig);

      try {
        // Try to verify using SMTP first (faster and more reliable for Gmail)
        const smtpResult = await gmailReader.verifyCredentials();
        if (smtpResult.success) {
          return res.json(smtpResult);
        }
        // If SMTP failed, fall back to IMAP verification
        console.log('SMTP verification failed, trying IMAP:', smtpResult.message);
      } catch (smtpError) {
        console.log('SMTP verification threw an error, trying IMAP:', smtpError);
      }

      // Fall back to IMAP connection testing
      // Create a new IMAP connection for testing
      const testImap = new Imap({
        user,
        password,
        host,
        port,
        tls,
        tlsOptions: { rejectUnauthorized: false },
        authTimeout: 30000, // Increase auth timeout
        connTimeout: 30000  // Increase connection timeout
      });

      // Set up a promise to handle the connection test
      const connectionTest = new Promise<{success: boolean, message: string}>((resolve, reject) => {
        // Set a timeout to prevent hanging
        const timeout = setTimeout(() => {
          try {
            testImap.end();
          } catch (e) {
            // Ignore errors when ending the connection
          }
          resolve({
            success: false,
            message: "Connection timeout. Please check your credentials and network. Gmail sometimes blocks automated login attempts. Try again later or visit your Google account security settings."
          });
        }, 30000); // 30 second timeout

        // Handle errors
        testImap.once('error', (err: Error) => {
          clearTimeout(timeout);
          console.log('IMAP connection error:', err.message);

          // Parse the error message to provide more helpful feedback
          let friendlyMessage = `Connection failed: ${err.message}`;

          if (err.message.includes('Invalid credentials') || err.message.includes('Authentication failed')) {
            friendlyMessage = 'Authentication failed: Please check your email and app password. Make sure you\'re using an App Password if you have 2-factor authentication enabled.';
          } else if (err.message.includes('ENOTFOUND') || err.message.includes('getaddrinfo')) {
            friendlyMessage = 'Could not reach Gmail server: Please check your internet connection and host settings';
          } else if (err.message.includes('ETIMEDOUT')) {
            friendlyMessage = 'Connection timed out: Gmail server might be blocking the request or there are network issues. Try again later.';
          }

          resolve({
            success: false,
            message: friendlyMessage
          });
        });

        // Handle successful connection
        testImap.once('ready', () => {
          clearTimeout(timeout);
          testImap.getBoxes((err, boxes) => {
            if (err) {
              resolve({
                success: true,
                message: "Connected successfully, but couldn't list mailboxes."
              });
            } else {
              resolve({
                success: true,
                message: "Connected successfully! Gmail credentials are working."
              });
            }

            // Close the connection
            try {
              testImap.end();
            } catch (e) {
              // Ignore errors when ending the connection
            }
          });
        });

        // Start the connection
        testImap.connect();
      });

      // Wait for the connection test to complete
      const result = await connectionTest;

      // Send the result
      res.json(result);
    } catch (error) {
      res.status(500).json({
        success: false,
        message: `Failed to test connection: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  });

  // Start Gmail reader
  app.post("/api/gmail-reader/start", (_req: Request, res: Response) => {
    try {
      gmailReader.start();
      res.json({ message: "Gmail reader started successfully" });
    } catch (error) {
      res.status(500).json({
        message: "Failed to start Gmail reader",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Stop Gmail reader
  app.post("/api/gmail-reader/stop", (_req: Request, res: Response) => {
    try {
      gmailReader.stop();
      res.json({ message: "Gmail reader stopped successfully" });
    } catch (error) {
      res.status(500).json({
        message: "Failed to stop Gmail reader",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Clean up Gmail reader processed email logs by date
  app.post("/api/gmail-reader/cleanup-logs", (req: Request, res: Response) => {
    try {
      const { beforeDate, afterDate, daysToKeep } = req.body;

      // Parse dates if provided
      const options: { before?: Date, after?: Date, daysToKeep?: number } = {};

      if (beforeDate) {
        options.before = new Date(beforeDate);
      }

      if (afterDate) {
        options.after = new Date(afterDate);
      }

      if (daysToKeep) {
        options.daysToKeep = parseInt(daysToKeep, 10);
      }

      // Perform the cleanup
      const result = gmailReader.cleanupEmailLogsByDate(options);

      res.json({
        message: `Successfully cleaned up email logs: removed ${result.entriesRemoved}, kept ${result.entriesKept}`,
        ...result
      });
    } catch (error) {
      res.status(500).json({
        message: "Failed to clean up Gmail reader logs",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Reset Gmail tracking system (clear all processed email logs)
  app.post("/api/gmail-reader/reset-tracking", (_req: Request, res: Response) => {
    try {
      // Stop the Gmail reader first to clear any in-progress operations
      gmailReader.stop();

      // Clear all email logs
      const result = gmailReader.clearAllEmailLogs();

      // Restart with a clean state after a short delay
      setTimeout(() => {
        // Start Gmail reader again to force a fresh scan
        gmailReader.start();

        console.log('Gmail reader restarted with clean tracking state for fresh email scan');
      }, 2000);

      res.json({
        success: true,
        message: `Gmail tracking system reset successfully. Removed ${result.entriesRemoved} entries. Reader restarted to perform a complete fresh scan.`,
        details: result
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: `Error resetting Gmail tracking system: ${error instanceof Error ? error.message : String(error)}`,
      });
    }
  });

  // Full system cleanup endpoint
  app.post("/api/system/full-cleanup", async (req: Request, res: Response) => {
    try {
      const { confirmText } = req.body;

      // Safety check - require explicit confirmation
      if (confirmText !== "DELETE ALL DATA") {
        return res.status(400).json({
          message: "Confirmation failed. Please provide the correct confirmation text."
        });
      }

      // Stop Gmail reader first if it's running
      if (gmailReader.getStatus().isRunning) {
        gmailReader.stop();
      }

      // Clear email processing logs
      const emailLogsResult = gmailReader.clearAllEmailLogs();

      // Clear database (delete all campaigns and URLs)
      const dbResult = await storage.fullSystemCleanup();

      res.json({
        message: "Full system cleanup completed successfully",
        result: {
          campaignsDeleted: dbResult.campaignsDeleted,
          urlsDeleted: dbResult.urlsDeleted,
          emailLogsCleared: emailLogsResult.success,
          emailLogsRemoved: emailLogsResult.entriesRemoved
        }
      });
    } catch (error) {
      console.error("Error performing full system cleanup:", error);
      res.status(500).json({
        message: "Failed to perform full system cleanup",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Database migration - update campaign multiplier to decimal type
  app.post("/api/system/migrate-decimal-multiplier", async (_req: Request, res: Response) => {
    try {
      // Import the migration function
      const { updateMultiplierToDecimal } = await import("./migrations/decimal-multiplier");

      // Execute the migration
      const result = await updateMultiplierToDecimal();

      if (result.success) {
        console.log("✅ Multiplier migration successful:", result.message);
        res.status(200).json({
          message: "Multiplier migration completed successfully",
          details: result.message
        });
      } else {
        console.error("❌ Multiplier migration failed:", result.message);
        res.status(500).json({
          message: "Multiplier migration failed",
          details: result.message
        });
      }
    } catch (error) {
      console.error("Failed to run multiplier migration:", error);
      res.status(500).json({ message: "Failed to run multiplier migration" });
    }
  });

  // TrafficStar API Routes

  // Check if TrafficStar API is configured (has API key)
  app.get("/api/trafficstar/status", async (_req: Request, res: Response) => {
    try {
      const isConfigured = await trafficStarService.isConfigured();
      res.json({ configured: isConfigured });
    } catch (error) {
      console.error('Error checking TrafficStar configuration:', error);
      res.status(500).json({
        message: "Failed to check TrafficStar configuration",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Save TrafficStar API key
  app.post("/api/trafficstar/config", async (req: Request, res: Response) => {
    try {
      const result = insertTrafficstarCredentialSchema.safeParse(req.body);
      if (!result.success) {
        const validationError = fromZodError(result.error);
        return res.status(400).json({ message: validationError.message });
      }

      await trafficStarService.saveApiKey(result.data.apiKey);
      res.json({ success: true, message: "TrafficStar API key saved successfully" });
    } catch (error) {
      console.error('Error saving TrafficStar API key:', error);
      res.status(500).json({
        message: "Failed to save TrafficStar API key",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Get TrafficStar campaigns
  app.get("/api/trafficstar/campaigns", async (_req: Request, res: Response) => {
    try {
      const campaigns = await trafficStarService.getCampaigns();
      res.json(campaigns);
    } catch (error) {
      console.error('Error fetching TrafficStar campaigns:', error);
      res.status(500).json({
        message: "Failed to fetch TrafficStar campaigns",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Get TrafficStar campaign by ID
  app.get("/api/trafficstar/campaigns/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid campaign ID" });
      }

      const campaign = await trafficStarService.getCampaign(id);
      res.json(campaign);
    } catch (error) {
      console.error(`Error fetching TrafficStar campaign ${req.params.id}:`, error);
      res.status(500).json({
        message: `Failed to fetch TrafficStar campaign ${req.params.id}`,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Get TrafficStar campaign spent value
  app.get("/api/trafficstar/campaigns/:id/spent", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid campaign ID" });
      }

      // Get date range from query parameters
      const dateFrom = req.query.dateFrom as string | undefined;
      const dateUntil = req.query.dateUntil as string | undefined;

      // Validate date format if provided (YYYY-MM-DD)
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (dateFrom && !dateRegex.test(dateFrom)) {
        return res.status(400).json({ message: "Invalid dateFrom format. Use YYYY-MM-DD" });
      }
      if (dateUntil && !dateRegex.test(dateUntil)) {
        return res.status(400).json({ message: "Invalid dateUntil format. Use YYYY-MM-DD" });
      }

      const stats = await trafficStarService.getCampaignSpentValue(id, dateFrom, dateUntil);
      res.json(stats);
    } catch (error) {
      console.error(`Error fetching spent value for TrafficStar campaign ${req.params.id}:`, error);
      res.status(500).json({
        message: `Failed to fetch spent value for TrafficStar campaign ${req.params.id}`,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Get saved TrafficStar campaigns from database
  app.get("/api/trafficstar/saved-campaigns", async (_req: Request, res: Response) => {
    try {
      const campaigns = await trafficStarService.getSavedCampaigns();
      res.json(campaigns);
    } catch (error) {
      console.error('Error fetching saved TrafficStar campaigns:', error);
      res.status(500).json({
        message: "Failed to fetch saved TrafficStar campaigns",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Perform campaign action (pause/activate)
  app.post("/api/trafficstar/campaigns/action", async (req: Request, res: Response) => {
    try {
      const result = trafficstarCampaignActionSchema.safeParse(req.body);
      if (!result.success) {
        const validationError = fromZodError(result.error);
        return res.status(400).json({ message: validationError.message });
      }

      const { campaignId, action } = result.data;

      // INSTANT DB UPDATE FIRST - Make the change instantly visible in the UI
      try {
        const targetActive = action === 'activate';
        const targetStatus = action === 'activate' ? 'enabled' : 'paused';

        // Update database first - this is what the user will see immediately
        await db.update(trafficstarCampaigns)
          .set({
            active: targetActive,
            status: targetStatus,
            lastRequestedAction: action,
            lastRequestedActionAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(trafficstarCampaigns.trafficstarId, campaignId.toString()));
      } catch (dbError) {
        console.error(`Error updating campaign ${campaignId} in database: ${dbError}`);
        // Continue even if there's an error, as the API call might still work
      }

      // IMMEDIATE RESPONSE - Respond to user right away
      res.json({
        success: true,
        message: `Campaign ${campaignId} ${action === 'pause' ? 'paused' : 'activated'} successfully`,
        statusChanged: true, // Always true since we updated DB first
        pendingSync: false, // Don't show pending status in UI
        lastRequestedAction: action,
        lastRequestedActionAt: new Date().toISOString(),
        timestamp: new Date().toISOString()
      });

      // BACKGROUND API CALL - Process API call after response is sent
      // This way API delays won't affect the user experience
      setTimeout(() => {
        try {
          if (action === 'pause') {
            trafficStarService.pauseCampaign(campaignId)
              .catch(error => console.error(`Background API call to pause campaign ${campaignId} failed:`, error));
          } else if (action === 'activate') {
            trafficStarService.activateCampaign(campaignId)
              .catch(error => console.error(`Background API call to activate campaign ${campaignId} failed:`, error));
          }
        } catch (apiError) {
          console.error(`Error in background API operation for campaign ${campaignId}:`, apiError);
          // Error in background process - already responded to user, so just log it
        }
      }, 100); // Start background processing after a small delay
    } catch (error) {
      console.error('Error performing TrafficStar campaign action:', error);
      res.status(500).json({
        message: "Failed to perform TrafficStar campaign action",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Update campaign daily budget
  app.post("/api/trafficstar/campaigns/budget", async (req: Request, res: Response) => {
    try {
      const result = trafficstarCampaignBudgetSchema.safeParse(req.body);
      if (!result.success) {
        const validationError = fromZodError(result.error);
        return res.status(400).json({ message: validationError.message });
      }

      const { campaignId, maxDaily } = result.data;

      // Update database first for immediate UI response
      try {
        await db.update(trafficstarCampaigns)
          .set({
            maxDaily: maxDaily.toString(), // Convert to string for DB numeric type
            lastBudgetUpdate: new Date(),
            lastBudgetUpdateValue: maxDaily.toString(), // Store the exact value we're setting
            updatedAt: new Date()
          })
          .where(eq(trafficstarCampaigns.trafficstarId, campaignId.toString()));
      } catch (dbError) {
        console.error(`Error updating campaign budget ${campaignId} in database: ${dbError}`);
        // Continue even if there's an error, as the API call might still work
      }

      // IMMEDIATE RESPONSE - Respond to user right away
      res.json({
        success: true,
        message: `Campaign ${campaignId} budget updated to ${maxDaily} successfully`,
        timestamp: new Date().toISOString()
      });

      // BACKGROUND API CALL - Process API call after response is sent
      setTimeout(() => {
        try {
          trafficStarService.updateCampaignDailyBudget(campaignId, maxDaily)
            .catch(error => console.error(`Background API call to update budget for campaign ${campaignId} failed:`, error));

          // Refresh campaign in background
          trafficStarService.getCampaign(campaignId)
            .catch(error => console.error(`Background API call to refresh campaign ${campaignId} failed:`, error));
        } catch (apiError) {
          console.error(`Error in background budget update for campaign ${campaignId}:`, apiError);
          // Error in background process - already responded to user, so just log it
        }
      }, 100); // Start background processing after a small delay
    } catch (error) {
      console.error('Error updating TrafficStar campaign budget:', error);
      res.status(500).json({
        message: "Failed to update TrafficStar campaign budget",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Force immediate budget update for a campaign (used when budget update time changes)
  app.post("/api/trafficstar/campaigns/force-budget-update", async (req: Request, res: Response) => {
    try {
      const { campaignId } = req.body;

      if (!campaignId || isNaN(Number(campaignId))) {
        return res.status(400).json({ message: "Invalid campaign ID" });
      }

      // Get campaign from database
      const campaign = await storage.getCampaign(Number(campaignId));
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }

      // Only process if TrafficStar integration is enabled
      if (!campaign.trafficstarCampaignId || !campaign.autoManageTrafficstar) {
        return res.status(400).json({
          message: "Cannot force budget update: TrafficStar integration not enabled for this campaign"
        });
      }

      // Manually trigger auto-management for this campaign
      console.log(`🔄 Forcing immediate TrafficStar budget update for campaign ${campaignId}`);

      try {
        // Set daily budget to $10.15 via TrafficStar API
        await trafficStarService.updateCampaignDailyBudget(
          Number(campaign.trafficstarCampaignId),
          10.15
        );

        // Update last sync time in campaigns table
        await db.update(campaigns)
          .set({
            lastTrafficstarSync: new Date(),
            updatedAt: new Date()
          })
          .where(eq(campaigns.id, Number(campaignId)));

        return res.json({
          success: true,
          message: `Budget for campaign ${campaignId} updated to $10.15 successfully`,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error(`Error forcing budget update for campaign ${campaignId}:`, error);
        return res.status(500).json({
          success: false,
          message: "Failed to force budget update",
          error: error instanceof Error ? error.message : String(error)
        });
      }
    } catch (error) {
      console.error('Error forcing TrafficStar budget update:', error);
      res.status(500).json({
        message: "Failed to force TrafficStar budget update",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Update campaign end time
  app.post("/api/trafficstar/campaigns/end-time", async (req: Request, res: Response) => {
    try {
      const result = trafficstarCampaignEndTimeSchema.safeParse(req.body);
      if (!result.success) {
        const validationError = fromZodError(result.error);
        return res.status(400).json({ message: validationError.message });
      }

      const { campaignId, scheduleEndTime } = result.data;

      // Update database first for immediate UI response
      try {
        await db.update(trafficstarCampaigns)
          .set({
            scheduleEndTime: scheduleEndTime,
            lastEndTimeUpdate: new Date(),
            lastEndTimeUpdateValue: scheduleEndTime, // Store the exact value we're setting
            updatedAt: new Date()
          })
          .where(eq(trafficstarCampaigns.trafficstarId, campaignId.toString()));
      } catch (dbError) {
        console.error(`Error updating campaign end time ${campaignId} in database: ${dbError}`);
        // Continue even if there's an error, as the API call might still work
      }

      // IMMEDIATE RESPONSE - Respond to user right away
      res.json({
        success: true,
        message: `Campaign ${campaignId} end time updated to ${scheduleEndTime} successfully`,
        timestamp: new Date().toISOString()
      });

      // BACKGROUND API CALL - Process API call after response is sent
      setTimeout(() => {
        try {
          trafficStarService.updateCampaignEndTime(campaignId, scheduleEndTime)
            .catch(error => console.error(`Background API call to update end time for campaign ${campaignId} failed:`, error));

          // Refresh campaign in background
          trafficStarService.getCampaign(campaignId)
            .catch(error => console.error(`Background API call to refresh campaign ${campaignId} failed:`, error));
        } catch (apiError) {
          console.error(`Error in background end time update for campaign ${campaignId}:`, apiError);
          // Error in background process - already responded to user, so just log it
        }
      }, 100); // Start background processing after a small delay
    } catch (error) {
      console.error('Error updating TrafficStar campaign end time:', error);
      res.status(500).json({
        message: "Failed to update TrafficStar campaign end time",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Database migration - add TrafficStar fields to campaigns table
  app.post("/api/system/migrate-trafficstar-fields", async (_req: Request, res: Response) => {
    try {
      // Import the migration function
      const { addTrafficStarFields } = await import("./migrations/add-trafficstar-fields");

      // Execute the migration
      const result = await addTrafficStarFields();

      if (result.success) {
        console.log("✅ TrafficStar fields migration successful:", result.message);
        res.status(200).json({
          message: "TrafficStar fields migration completed successfully",
          details: result.message
        });
      } else {
        console.error("❌ TrafficStar fields migration failed:", result.message);
        res.status(500).json({
          message: "TrafficStar fields migration failed",
          details: result.message
        });
      }
    } catch (error) {
      console.error("Failed to add TrafficStar fields:", error);
      res.status(500).json({ message: "Failed to add TrafficStar fields to campaigns table" });
    }
  });

  // Check migration status - Find out if migrations are needed
  app.get("/api/system/check-migrations", async (_req: Request, res: Response) => {
    try {
      // Import the migration check functions
      const {
        isBudgetUpdateTimeMigrationNeeded,
        isTrafficStarFieldsMigrationNeeded
      } = await import("./migrations/check-migration-needed");

      // Check migration status
      const budgetUpdateTimeMigrationNeeded = await isBudgetUpdateTimeMigrationNeeded();
      const trafficStarFieldsMigrationNeeded = await isTrafficStarFieldsMigrationNeeded();

      // Return migration status
      res.status(200).json({
        budgetUpdateTimeMigrationNeeded,
        trafficStarFieldsMigrationNeeded,
        migrationNeeded: budgetUpdateTimeMigrationNeeded || trafficStarFieldsMigrationNeeded,
        message: "Migration status checked successfully"
      });
    } catch (error) {
      console.error("Failed to check migration status:", error);
      res.status(500).json({
        message: "Failed to check migration status",
        error: error instanceof Error ? error.message : String(error),
        // Assume migrations are needed if check fails
        migrationNeeded: true,
        budgetUpdateTimeMigrationNeeded: true,
        trafficStarFieldsMigrationNeeded: true
      });
    }
  });

  // Database migration - add budget update time field to campaigns table
  app.post("/api/system/migrate-budget-update-time", async (_req: Request, res: Response) => {
    try {
      // Import the migration function
      const { addBudgetUpdateTimeField } = await import("./migrations/add-budget-update-time");

      // Execute the migration
      const result = await addBudgetUpdateTimeField();

      if (result.success) {
        console.log("✅ Budget update time field migration successful");
        res.status(200).json({
          message: "Budget update time field migration completed successfully"
        });
      } else {
        console.error("❌ Budget update time field migration failed:", result.error);
        res.status(500).json({
          message: "Budget update time field migration failed",
          error: result.error
        });
      }
    } catch (error) {
      console.error("Failed to add budget update time field:", error);
      res.status(500).json({ message: "Failed to add budget update time field to campaigns table" });
    }
  });

  /**
   * Test route for verifying the budget adjustment feature after 10-minute spent value pause
   * This simulates the process of recalculating the budget after a campaign has been paused
   * due to exceeding the $10 daily spent value threshold.
   */
  app.post("/api/system/test-budget-adjustment", async (_req: Request, res: Response) => {
    // Reset test variables first to ensure clean state
    process.env.TEST_MODE = 'false';
    process.env.TEST_MODE_SPENT_VALUE_PAUSE = 'false';
    delete process.env.TEST_CAMPAIGN_ID;
    delete process.env.TEST_PAUSE_TIME;
    delete process.env.TEST_RECHECK_TIME;
    delete process.env.TEST_UTC_DATE;

    try {
      console.log('🧪 TEST: Budget Adjustment After Spent Value Pause');

      // Get a campaign with auto-management enabled
      const [campaign] = await db
        .select()
        .from(campaigns)
        .where(eq(campaigns.autoManageTrafficstar, true));

      if (!campaign) {
        return res.json({
          success: false,
          message: 'No auto-managed campaign found for testing'
        });
      }

      console.log(`Found campaign ${campaign.id} for testing`);

      if (!campaign.trafficstarCampaignId) {
        return res.json({
          success: false,
          message: 'Campaign does not have TrafficStar ID'
        });
      }

      const trafficstarId = Number(campaign.trafficstarCampaignId);

      // 1. Manually trigger the budget adjustment process
      console.log(`Manually triggering budget adjustment process for campaign ${trafficstarId}`);

      // Get current UTC date
      const currentUtcDate = new Date().toISOString().split('T')[0];

      // Create a pause state in the past (10 min ago)
      const pausedAt = new Date(Date.now() - 15 * 60 * 1000); // 15 minutes ago
      const recheckAt = new Date(Date.now() - 5 * 60 * 1000); // 5 minutes ago (so it's ready for recheck)

      // We need to simulate a pause due to spent value
      // Since spentValuePausedCampaigns is private in the service,
      // let's directly adjust the date and run the auto-management to test

      // First, pause the campaign to simulate spent value pause
      await trafficStarService.pauseCampaign(trafficstarId);

      // Then we'll activate the test mode to simulate a pause that happened in the past
      process.env.TEST_MODE_SPENT_VALUE_PAUSE = 'true';
      process.env.TEST_CAMPAIGN_ID = trafficstarId.toString();
      process.env.TEST_PAUSE_TIME = pausedAt.toISOString();
      process.env.TEST_RECHECK_TIME = recheckAt.toISOString();
      process.env.TEST_UTC_DATE = currentUtcDate;

      console.log(`Set pause info for campaign ${trafficstarId} with recheck time in the past`);

      // Make sure we have some URLs with clicks
      const existingUrls = await db
        .select()
        .from(urls)
        .where(eq(urls.campaignId, campaign.id));

      if (existingUrls.length === 0) {
        // Create a test URL
        await db.insert(urls).values({
          campaignId: campaign.id,
          name: 'Test URL for Budget Adjustment',
          targetUrl: 'https://example.com/test',
          clickLimit: 5000,
          clicks: 0,
          status: 'active',
          originalClickLimit: 5000,
          createdAt: new Date(),
          updatedAt: new Date()
        });

        console.log('Created test URL with 5000 clicks for budget adjustment test');
      } else {
        // Update existing URLs to be active with clicks
        await db.update(urls)
          .set({
            clickLimit: 5000,
            clicks: 0,
            status: 'active',
            updatedAt: new Date()
          })
          .where(eq(urls.campaignId, campaign.id));

        console.log('Updated existing URLs to be active with 5000 clicks');
      }

      // 2. Enable test mode to simulate spent value
      process.env.TEST_MODE = 'true';

      // 3. Trigger the spent value check, which should detect the recheck time has passed
      //    and invoke the budget adjustment process
      console.log('Running spent value check to trigger budget adjustment...');
      await trafficStarService.checkCampaignsSpentValue();

      // Calculate pending click pricing and other data for the UI
      const activeUrls = await db
        .select()
        .from(urls)
        .where(
          and(
            eq(urls.campaignId, campaign.id),
            eq(urls.status, 'active')
          )
        );

      const activeUrlsCount = activeUrls.length;

      // Calculate total click capacity
      let totalClickCapacity = 0;
      activeUrls.forEach(url => {
        totalClickCapacity += url.clickLimit || 0;
      });

      // Calculate pricing using pricePerThousand or a default
      const pricePerThousand = parseFloat(campaign.pricePerThousand?.toString() || '1000.00');
      const pendingClickPricing = (totalClickCapacity / 1000) * pricePerThousand;

      // Use a simulated current spent value of $10.30 (test mode will enforce this)
      const currentSpentValue = 10.30;

      // Calculate new daily budget
      const newDailyBudget = currentSpentValue + pendingClickPricing;

      // Format end date time (current UTC date 23:59)
      const endDateObj = new Date();
      endDateObj.setUTCHours(23, 59, 0, 0);
      const formattedEndDate = endDateObj.toISOString().split('T')[0];
      const formattedEndTime = endDateObj.toISOString().split('T')[1].substring(0, 5);
      const newEndDateTime = `${formattedEndDate} ${formattedEndTime}`;

      // Get current status
      const currentStatus = await trafficStarService.getCachedCampaignStatus(trafficstarId);
      const finalStatus = currentStatus?.active ? "Active" : "Paused";

      // 4. Clean up
      process.env.TEST_MODE = 'false';
      process.env.TEST_MODE_SPENT_VALUE_PAUSE = 'false';
      delete process.env.TEST_CAMPAIGN_ID;
      delete process.env.TEST_PAUSE_TIME;
      delete process.env.TEST_RECHECK_TIME;
      delete process.env.TEST_UTC_DATE;

      // Return detailed test results for UI
      res.json({
        success: true,
        message: 'Budget adjustment test completed successfully',
        campaignId: campaign.id,
        trafficstarId,
        currentUtcDate,
        currentSpentValue,
        activeUrlsCount,
        totalClickCapacity,
        pendingClickPricing,
        newDailyBudget,
        newEndDateTime,
        finalStatus,
        testMode: true
      });
    } catch (error) {
      console.error('Error in test-budget-adjustment:', error);

      // Clean up test environment variables on error
      process.env.TEST_MODE = 'false';
      process.env.TEST_MODE_SPENT_VALUE_PAUSE = 'false';
      delete process.env.TEST_CAMPAIGN_ID;
      delete process.env.TEST_PAUSE_TIME;
      delete process.env.TEST_RECHECK_TIME;
      delete process.env.TEST_UTC_DATE;

      res.json({
        success: false,
        message: 'Error testing budget adjustment functionality',
        error: String(error)
      });
    }
  });

  /**
   * Comprehensive test route for verifying both click threshold and spent value monitoring functionality
   */
  app.post("/api/system/test-spent-value-monitoring", async (_req: Request, res: Response) => {
    try {
      // Temporarily set test mode environment variable
      process.env.TEST_MODE = 'true';

      // Get all campaigns with auto-management enabled
      const campaignsToCheck = await db
        .select()
        .from(campaigns)
        .where(
          and(
            eq(campaigns.autoManageTrafficstar, true),
            isNotNull(campaigns.trafficstarCampaignId)
          )
        );

      console.log(`TEST: Found ${campaignsToCheck.length} campaigns with auto-management enabled`);

      // Test URL counts - to verify click threshold functionality
      const urlCounts = await Promise.all(campaignsToCheck.map(async (campaign) => {
        // Get all active URLs for the campaign
        const activeUrls = await db
          .select()
          .from(urls)
          .where(
            and(
              eq(urls.campaignId, campaign.id),
              eq(urls.status, 'active')
            )
          );

        // Get all paused URLs for the campaign
        const pausedUrls = await db
          .select()
          .from(urls)
          .where(
            and(
              eq(urls.campaignId, campaign.id),
              eq(urls.status, 'paused')
            )
          );

        // Calculate total active clicks
        const activeClicksTotal = activeUrls.reduce((sum, url) => sum + (url.clickLimit - url.clicks), 0);

        return {
          campaignId: campaign.id,
          activeUrlCount: activeUrls.length,
          pausedUrlCount: pausedUrls.length,
          activeClicksRemaining: activeClicksTotal,
          // Would this campaign be activated/paused based on click threshold?
          wouldActivateByClicks: activeClicksTotal >= 15000,
          wouldPauseByClicks: activeClicksTotal <= 5000
        };
      }));

      // Manually run the spent value check function
      await trafficStarService.checkCampaignsSpentValue();

      // Check the results of the spent value check
      const results = await Promise.all(campaignsToCheck.map(async (campaign, index) => {
        if (!campaign.trafficstarCampaignId) return null;

        // Get TrafficStar campaign ID converted to number
        const trafficstarId = isNaN(Number(campaign.trafficstarCampaignId)) ?
          parseInt(campaign.trafficstarCampaignId.replace(/\D/g, '')) :
          Number(campaign.trafficstarCampaignId);

        // Get current date in UTC
        const currentUtcDate = new Date().toISOString().split('T')[0];

        // Get current status
        const [dbCampaign] = await db
          .select()
          .from(trafficstarCampaigns)
          .where(eq(trafficstarCampaigns.trafficstarId, trafficstarId.toString()));

        // Get pause info from TrafficStar service
        const pauseInfo = trafficStarService.getSpentValuePauseInfo(trafficstarId, currentUtcDate);

        // Get spent value for today (this will return test mock data since we're in test mode)
        const spentValueData = await trafficStarService.getCampaignSpentValue(trafficstarId, currentUtcDate, currentUtcDate);

        // Get related URL count data
        const urlData = urlCounts[index];

        return {
          campaignId: campaign.id,
          trafficstarId,
          // TrafficStar status
          currentStatus: dbCampaign ? dbCampaign.status : 'unknown',
          isActive: dbCampaign ? dbCampaign.active : false,

          // Spent value data
          dailySpentValue: spentValueData?.totalSpent || 0,
          spentThresholdExceeded: (spentValueData?.totalSpent || 0) > 10,
          isPausedDueToSpentValue: Boolean(pauseInfo),
          spentValuePauseInfo: pauseInfo ? {
            pausedAt: pauseInfo.pausedAt.toISOString(),
            recheckAt: pauseInfo.recheckAt.toISOString(),
            minutesRemaining: Math.ceil((pauseInfo.recheckAt.getTime() - Date.now()) / (60 * 1000))
          } : null,

          // URL and click data
          urlData: urlData || {
            activeUrlCount: 0,
            pausedUrlCount: 0,
            activeClicksRemaining: 0,
            wouldActivateByClicks: false,
            wouldPauseByClicks: true
          },

          // Overall status of which mechanism is controlling the campaign
          clickThresholdActive: pauseInfo === null, // Click threshold only works when not paused due to spent value
          controllingFactor: pauseInfo
            ? 'spent_value_threshold'
            : (urlData?.wouldPauseByClicks
              ? 'click_threshold_pause'
              : (urlData?.wouldActivateByClicks
                ? 'click_threshold_activate'
                : 'other'))
        };
      }));

      // Reset test mode
      process.env.TEST_MODE = 'false';

      res.json({
        success: true,
        message: 'Comprehensive test completed for both spent value and click threshold functionality',
        results: results.filter(Boolean)
      });
    } catch (error) {
      console.error('Error in test-spent-value-monitoring:', error);
      res.status(500).json({
        success: false,
        message: 'Error testing auto-management functionality',
        error: String(error)
      });
    }
  });

  /**
   * Test routes for manually verifying specific auto-management scenarios
   * These endpoints allow testing of:
   * 1. Date change behavior
   * 2. Click threshold (15,000/5,000) behavior
   * 3. Spent value ($10) behavior
   * 4. 10-minute recheck after spent value pause
   */

  // Test 1: Date Change Testing
  app.post("/api/system/test-date-change", async (_req: Request, res: Response) => {
    try {
      console.log('🧪 TEST 1: Date Change Testing');

      // Get a campaign with auto-management enabled
      const [campaign] = await db
        .select()
        .from(campaigns)
        .where(eq(campaigns.autoManageTrafficstar, true));

      if (!campaign) {
        return res.status(400).json({
          success: false,
          message: 'No auto-managed campaign found for testing'
        });
      }

      console.log(`Found campaign ${campaign.id} for testing`);

      // Update lastTrafficstarSync to yesterday to simulate a date change
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);

      await db.update(campaigns)
        .set({
          lastTrafficstarSync: yesterday,
          updatedAt: new Date()
        })
        .where(eq(campaigns.id, campaign.id));

      console.log(`Updated campaign ${campaign.id} lastTrafficstarSync to yesterday: ${yesterday.toISOString()}`);

      // Trigger auto-management
      console.log('Triggering auto-management to test date change behavior...');
      await trafficStarService.autoManageCampaigns();

      res.json({
        success: true,
        message: 'Date change test completed - check logs for results'
      });
    } catch (error) {
      console.error('Error in test-date-change:', error);
      res.status(500).json({
        success: false,
        message: 'Error testing date change functionality',
        error: String(error)
      });
    }
  });

  // Test 2: Click Threshold Testing
  app.post("/api/system/test-click-threshold", async (_req: Request, res: Response) => {
    try {
      console.log('🧪 TEST 2: Click Threshold Testing');

      // Get a campaign with auto-management enabled
      const [campaign] = await db
        .select()
        .from(campaigns)
        .where(eq(campaigns.autoManageTrafficstar, true));

      if (!campaign) {
        return res.status(400).json({
          success: false,
          message: 'No auto-managed campaign found for testing'
        });
      }

      console.log(`Found campaign ${campaign.id} for testing`);

      // Make sure we test with a fresh state - activate the campaign first
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = campaign.trafficstarCampaignId;

        // Make sure campaign is active to start
        await trafficStarService.activateCampaign(Number(trafficstarId));
        console.log(`Activated TrafficStar campaign ${trafficstarId} for testing`);
      }

      // Step 1: Make sure spent value pause mechanism is not active
      // This ensures click threshold checks will run
      const currentUtcDate = new Date().toISOString().split('T')[0];
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const pauseInfo = trafficStarService.getSpentValuePauseInfo(trafficstarId, currentUtcDate);
        if (pauseInfo) {
          console.log(`Campaign was paused due to spent value - clearing this state for testing`);
          trafficStarService.clearSpentValuePause(trafficstarId);
        }
      }

      // Step 2: Test scenario 1 - Less than 5000 clicks remaining
      // Get existing URLs for the campaign
      const existingUrls = await db
        .select()
        .from(urls)
        .where(eq(urls.campaignId, campaign.id));

      console.log(`Campaign has ${existingUrls.length} URLs`);

      // Setting click limit to exactly 3000 (well below the 5000 threshold)
      if (existingUrls.length === 0) {
        // Create a test URL with less than 5000 clicks
        await db.insert(urls).values({
          campaignId: campaign.id,
          name: 'Test URL 1 - Below Threshold',
          targetUrl: 'https://example.com/test1',
          clickLimit: 3000,
          clicks: 0,
          status: 'active',
          originalClickLimit: 3000,
          createdAt: new Date(),
          updatedAt: new Date()
        });

        console.log('Created test URL with 3000 clicks remaining (well below 5000 threshold)');
      } else {
        // Update existing URLs for testing
        await db.update(urls)
          .set({
            clickLimit: 3000,
            clicks: 0,
            status: 'active',
            updatedAt: new Date()
          })
          .where(eq(urls.campaignId, campaign.id));

        console.log('Updated existing URLs to have 3000 clicks remaining (well below 5000 threshold)');
      }

      // Trigger auto-management to see the pause due to low clicks
      console.log('✅ TEST CASE: Campaign with less than 5000 clicks should PAUSE');
      console.log('Triggering auto-management to test pause due to low clicks (<5000)...');
      await trafficStarService.autoManageCampaigns();

      // Wait a moment to let the API call complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Check campaign status after pause attempt
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const campaignStatus = await trafficStarService.getCachedCampaignStatus(trafficstarId);
        console.log(`Campaign status after low clicks test: ${JSON.stringify(campaignStatus)}`);
      }

      // Step 3: Test scenario 2 - More than 15000 clicks remaining
      await db.update(urls)
        .set({
          clickLimit: 20000,
          clicks: 0,
          status: 'active',
          updatedAt: new Date()
        })
        .where(eq(urls.campaignId, campaign.id));

      console.log('Updated URLs to have 20000 clicks remaining (well above 15000 threshold)');

      // Trigger auto-management to see the activation due to high clicks
      console.log('✅ TEST CASE: Campaign with more than 15000 clicks should ACTIVATE');
      console.log('Triggering auto-management to test activation due to high clicks (>15000)...');
      await trafficStarService.autoManageCampaigns();

      // Wait a moment to let the API call complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Check campaign status after activation attempt
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const campaignStatus = await trafficStarService.getCachedCampaignStatus(trafficstarId);
        console.log(`Campaign status after high clicks test: ${JSON.stringify(campaignStatus)}`);
      }

      // Step 4: Now test spent value overriding click threshold
      console.log('✅ TEST CASE: Spent value over $10 should OVERRIDE click threshold mechanism');

      // Enable test mode to simulate high spent values
      process.env.TEST_MODE = 'true';

      // Make sure campaign is active
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        await trafficStarService.activateCampaign(Number(trafficstarId));
      }

      // Run spent value check (in test mode, should report >$10 and pause)
      console.log('Running spent value check with clicks still >15000...');
      await trafficStarService.checkCampaignsSpentValue();

      // Wait a moment to let the API call complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Even though clicks are high, campaign should be paused due to spent value
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const campaignStatus = await trafficStarService.getCachedCampaignStatus(trafficstarId);
        console.log(`Campaign status after spent value override test: ${JSON.stringify(campaignStatus)}`);

        const pauseInfo = trafficStarService.getSpentValuePauseInfo(trafficstarId, currentUtcDate);
        if (pauseInfo) {
          console.log(`Spent value mechanism properly overrode click threshold mechanism`);
          console.log(`Campaign paused with spent value > $10 even though clicks > 15000`);
          console.log(`Recheck scheduled for: ${pauseInfo.recheckAt.toISOString()}`);
          console.log(`Minutes until recheck: ${Math.ceil((pauseInfo.recheckAt.getTime() - Date.now()) / (60 * 1000))}`);
        } else {
          console.log(`ERROR: Campaign was NOT paused due to high spent value despite clicks > 15000`);
        }
      }

      // Step 5: Verify that the spent value mechanism disables click threshold
      console.log('✅ TEST CASE: Click threshold should be DISABLED until next UTC date change');
      console.log('Trying to reactivate campaign by updating clicks...');

      // Trigger auto-management to verify click threshold is disabled
      // Even with lots of clicks, campaign should remain paused
      console.log('Triggering auto-management with spent value pause active...');
      await trafficStarService.autoManageCampaigns();

      // Wait a moment to let the API call complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Campaign should still be paused despite high clicks
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const campaignStatus = await trafficStarService.getCachedCampaignStatus(trafficstarId);
        console.log(`Final campaign status: ${JSON.stringify(campaignStatus)}`);
        console.log(`Campaign should still be paused despite high clicks (${campaignStatus?.active === false ? 'CORRECT' : 'WRONG'})`);
      }

      // Step 6: Test that mechanism resets after UTC date change
      console.log('✅ TEST CASE: Click threshold should REACTIVATE after UTC date change');

      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        // Simulate a date change
        const newUtcDate = new Date();
        newUtcDate.setDate(newUtcDate.getDate() + 1);
        const newUtcDateStr = newUtcDate.toISOString().split('T')[0];

        console.log(`Current UTC date: ${currentUtcDate}, Simulating next UTC date: ${newUtcDateStr}`);

        // Check if pause info is cleared with new date
        const pauseInfo = trafficStarService.getSpentValuePauseInfo(trafficstarId, newUtcDateStr);
        console.log(`Pause info for new UTC date: ${pauseInfo ? 'Still active (WRONG)' : 'Cleared (CORRECT)'}`);
      }

      // Clean up
      process.env.TEST_MODE = 'false';

      res.json({
        success: true,
        message: 'Click threshold test completed - check logs for all test results'
      });
    } catch (error) {
      console.error('Error in test-click-threshold:', error);
      res.status(500).json({
        success: false,
        message: 'Error testing click threshold functionality',
        error: String(error)
      });
    }
  });

  // Test 3: Spent Value Testing
  app.post("/api/system/test-spent-value", async (_req: Request, res: Response) => {
    try {
      console.log('🧪 TEST 3: Spent Value Testing');

      // Enable test mode to get simulated spent value
      process.env.TEST_MODE = 'true';

      // Get a campaign with auto-management enabled
      const [campaign] = await db
        .select()
        .from(campaigns)
        .where(eq(campaigns.autoManageTrafficstar, true));

      if (!campaign) {
        return res.status(400).json({
          success: false,
          message: 'No auto-managed campaign found for testing'
        });
      }

      console.log(`Found campaign ${campaign.id} for testing`);

      // Make the campaign active in TrafficStar
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = campaign.trafficstarCampaignId;

        await db.update(trafficstarCampaigns)
          .set({
            active: true,
            status: 'enabled',
            updatedAt: new Date()
          })
          .where(eq(trafficstarCampaigns.trafficstarId, trafficstarId));

        console.log(`Set TrafficStar campaign ${trafficstarId} as active for testing`);
      }

      // Run spent value check (in test mode, should report >$10 and pause)
      console.log('Running spent value check to test pause due to high spent value...');
      await trafficStarService.checkCampaignsSpentValue();

      // Check if campaign was paused
      if (campaign.trafficstarCampaignId) {
        const trafficstarId = Number(campaign.trafficstarCampaignId);
        const currentUtcDate = new Date().toISOString().split('T')[0];
        const pauseInfo = trafficStarService.getSpentValuePauseInfo(trafficstarId, currentUtcDate);

        if (pauseInfo) {
          console.log(`Campaign was paused due to high spent value`);
          console.log(`Recheck scheduled for: ${pauseInfo.recheckAt.toISOString()}`);
          console.log(`Minutes until recheck: ${Math.ceil((pauseInfo.recheckAt.getTime() - Date.now()) / (60 * 1000))}`);
        } else {
          console.log(`Campaign was NOT paused due to high spent value - test failed`);
        }
      }

      // Check that click threshold is disabled after spent value pause
      console.log('Triggering auto-management to verify click threshold is disabled...');
      await trafficStarService.autoManageCampaigns();

      // Clean up
      process.env.TEST_MODE = 'false';

      res.json({
        success: true,
        message: 'Spent value test completed - check logs for results'
      });
    } catch (error) {
      console.error('Error in test-spent-value:', error);
      res.status(500).json({
        success: false,
        message: 'Error testing spent value functionality',
        error: String(error)
      });
    }
  });

  /**
   * Test route for verifying the URL budget handling functionality
   * This route allows testing the URL budget tracking and update functionality
   */
  app.post("/api/system/test-url-budget-update", async (req: Request, res: Response) => {
    try {
      const { campaignId, urlId, clickValue } = req.body;

      if (!campaignId || !urlId) {
        return res.status(400).json({
          success: false,
          message: "Missing required parameters: campaignId and urlId"
        });
      }

      // Get the campaign to check if it's linked to TrafficStar
      const campaign = await storage.getCampaign(parseInt(campaignId));
      if (!campaign) {
        return res.status(404).json({
          success: false,
          message: "Campaign not found"
        });
      }

      if (!campaign.trafficstarCampaignId) {
        return res.status(400).json({
          success: false,
          message: "Campaign is not linked to TrafficStar"
        });
      }

      // Get the URL to use its click limit
      const url = await storage.getUrl(parseInt(urlId));
      if (!url) {
        return res.status(404).json({
          success: false,
          message: "URL not found"
        });
      }

      console.log(`🧪 TEST: Tracking URL ${urlId} for budget update in campaign ${campaignId}`);

      // Track the URL for budget update
      const clicksToTrack = clickValue ? parseInt(clickValue) : url.clickLimit;
      await trafficStarService.trackNewUrlForBudgetUpdate(
        url.id,
        parseInt(campaignId),
        campaign.trafficstarCampaignId,
        clicksToTrack,
        campaign.pricePerThousand || 1000
      );

      // If immediate parameter is provided, instantly process the pending URL budgets
      if (req.body.immediate === true) {
        console.log(`🧪 TEST: Immediately processing pending URL budgets`);
        await trafficStarService.processPendingUrlBudgets();
      }

      res.json({
        success: true,
        message: `URL ${urlId} tracked for budget update in campaign ${campaignId}`,
        clicksTracked: clicksToTrack,
        processingTime: req.body.immediate ? 'Immediate' : '10 minutes'
      });
    } catch (error) {
      console.error('Error testing URL budget update:', error);
      res.status(500).json({
        success: false,
        message: "Error testing URL budget update functionality",
        error: String(error)
      });
    }
  });

  // Create an HTTP/2 capable server
  // We're using a regular HTTP server instead of SPDY for now due to compatibility issues
  // We'll handle the HTTP/2.0 headers in the individual route handlers
  return server;
}
import { Express, Request, Response } from 'express';
import { validateApiKey, requireAuth } from './middleware';
import { log } from '../vite';

// Register authentication routes
export function registerAuthRoutes(app: Express) {
  // API key verification route
  app.post('/api/auth/verify-key', (req: Request, res: Response) => {
    const { apiKey } = req.body;

    try {
      // Simple validation
      if (!apiKey) {
        return res.status(400).json({ message: 'API key is required' });
      }

      // Validate the API key
      const isValid = validateApiKey(apiKey);

      if (!isValid) {
        log(`API key verification failed - invalid key provided`, 'auth');
        return res.status(401).json({
          message: 'Invalid API key',
          authenticated: false
        });
      }

      // Set API key in cookie for future requests
      res.cookie('apiKey', apiKey, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
        sameSite: 'lax'
      });

      log(`API key verification successful`, 'auth');

      // Success response
      res.json({
        message: 'API key verified',
        authenticated: true
      });
    } catch (error) {
      console.error('API key verification error:', error);
      res.status(500).json({ message: 'An error occurred during verification' });
    }
  });

  // Check authentication status
  app.get('/api/auth/status', (req: Request, res: Response) => {
    try {
      // Get API key from cookie, header, or query param
      const apiKey = req.cookies?.apiKey ||
                    req.headers['x-api-key'] ||
                    req.query.apiKey;

      if (!apiKey) {
        return res.json({ authenticated: false });
      }

      // Validate the API key
      const isValid = validateApiKey(apiKey as string);

      res.json({ authenticated: isValid });
    } catch (error) {
      console.error('Auth status error:', error);
      res.json({ authenticated: false });
    }
  });

  // Clear API key cookie (logout)
  app.post('/api/auth/logout', (req: Request, res: Response) => {
    res.clearCookie('apiKey');
    res.json({ message: 'API key cleared' });
  });

  // Test route to verify auth is working
  app.get('/api/auth/test', requireAuth, (req: Request, res: Response) => {
    res.json({
      message: 'Authentication successful - API key is valid'
    });
  });
}root@vultr:/app## Create a client-side fixx
cat > /app/client-fix.txt << 'EOF'
Important: Look for any WebSocket connections in your client code and disable them.

Common places to look:
1. client/src/hooks/useWebSocket.ts or similar
2. client/src/contexts/WebSocketContext.tsx or similar
3. client/src/lib/websocket.ts or similar

When you find the WebSocket connection code, modify it to use regular API calls instead.
For example, replace:

const socket = new WebSocket('wss://localhost/v2');
socket.onmessage = (event) => {
  // handle message
};

With:
function fetchAPI(endpoint) {
  return fetch(`/api/${endpoint}`).then(res => res.json());
}
// Use fetchAPI instead of WebSocket
EOF

# Search for client-side WebSocket usage
find /app/client -type f -exec grep -l "WebSocket" {} \;
root@vultr:/app# # View the routes file to see WebSocket server setup
find /app/server -name "routes.ts" | xargs cat | grep -A 10 "WebSocketServer"
root@vultr:/app# # Restart the application
pm2 restart url-manager

# Wait a few seconds
sleep 5

# Test basic endpoint
curl http://localhost/api/test

# Test campaigns endpoint
curl http://localhost/api/campaigns
Use --update-env to update environment variables
[PM2] Applying action restartProcessId on app [url-manager](ids: [ 2 ])
[PM2] [url-manager](2) ✓
┌────┬────────────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id │ name           │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├────┼────────────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ 1  │ simple-app     │ default     │ 1.0.0   │ fork    │ 22946    │ 3m     │ 0    │ online    │ 0%       │ 58.2mb   │ root     │ disabled │
│ 2  │ url-manager    │ default     │ 1.0.0   │ fork    │ 23146    │ 0s     │ 1    │ online    │ 0%       │ 16.9mb   │ root     │ disabled │
└────┴────────────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
{"message":"API is working"}[{"id":1,"name":"Test Campaign","description":"This is a test campaign","trafficstar_id":null,"custom_path":null,"active":true,"click_threshold_activate":15000,"click_threshold_pause":5000,"created_at":"2025-04-26T12:23:34.520Z","updated_at":"2025-04-26T12:23:34.520Z","last_budget_update":null,"budget_adjusted_today":false,"last_spent_check":null,"daily_spent":"0.0000"}]root@vultr:/app# ^C
root@vultr:/app#       console.log(`Selected URL ID ${selectedUrl.id} (${selectedUrl.name}) for redirect`);

      // Increment click count
      await storage.incrementUrlClicks(selectedUrl.id);

      // Performance metrics
      const endTime = process.hrtime(startTime);
      const timeInMs = (endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2);

      // Handle the redirect based on the campaign's redirect method
      const targetUrl = selectedUrl.targetUrl;

      switch (campaign.redirectMethod) {
        case "meta_refresh":
          // Meta refresh redirect - completely invisible
          res.send(`
            <!DOCTYPE html>
            <html>
              <head>
                <meta http-equiv="refresh" content="0;url=${targetUrl}">
                <title></title>
                <style>body{display:none}</style>
              </head>
              <body></body>
            </html>
          `);
          break;

        case "double_meta_refresh":
          // For double meta refresh - completely invisible
          res.send(`
            <!DOCTYPE html>
            <html>
              <head>
                <meta http-equiv="refresh" content="0;url=${targetUrl}">
                <title></title>
                <style>body{display:none}</style>
                <script>
                  // Immediate redirect without any visible elements
                  window.location.href = "${targetUrl}";
                </script>
              </head>
              <body></body>
            </html>
t