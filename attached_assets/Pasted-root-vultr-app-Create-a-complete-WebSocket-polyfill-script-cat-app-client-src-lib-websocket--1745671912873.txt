root@vultr:/app# # Create a complete WebSocket polyfill script
cat > /app/client/src/lib/websocket-polyfill.ts << 'EOF'
/**
 * WebSocket Polyfill - replaces WebSocket with HTTP fallback
 * Add this to your client code to fix WebSocket connection issues
 */

// Store the original WebSocket constructor
const OriginalWebSocket = window.WebSocket;

// Create a dummy WebSocket implementation that uses fetch
class FetchWebSocket {
  url: string;
  readyState: number = 0; // CONNECTING
  onopen: ((event: any) => void) | null = null;
  onclose: ((event: any) => void) | null = null;
  onmessage: ((event: any) => void) | null = null;
  onerror: ((event: any) => void) | null = null;

  static CONNECTING = 0;
  static OPEN = 1;
  static CLOSING = 2;
  static CLOSED = 3;

  constructor(url: string) {
    this.url = url;
    console.log(`[WebSocket Polyfill] Created connection to ${url}`);

    // Simulate connecting
    setTimeout(() => {
      this.readyState = 1; // OPEN
      if (this.onopen) {
        this.onopen({ target: this });
      }
    }, 100);
  }

  send(data: string): void {
    console.log(`[WebSocket Polyfill] Sending data via fetch`);

    try {
      // Parse the message to get the endpoint
      const message = JSON.parse(data);
      const apiEndpoint = `/api/${message.type || 'default'}`;
EOFort { FetchWebSocket, OriginalWebSocket };tationer) this.onclose = null; null;
root@vultr:/app# # Find the routes.ts file
find /app/server -name routes.ts

# View the end of the routes.ts file to see where to add our test route
find /app/server -name routes.ts | xargs tail -n 20

# Now add our test route directly to the file
echo "
# Add this route to the end of the routes.ts file, before the return statement
# Find the line that returns 'httpServer' and add this right before it:

  app.get('/api/test-simple', (_req, res) => {
    res.json({
      message: 'API is working',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV
    });
  });

# Then use nano or another editor to add this route
"

# Use nano to edit the routes.ts file
nano /app/server/routes.ts
/app/server/routes.ts
/app/server/auth/routes.ts
==> /app/server/routes.ts <==
        success: true,
        message: `URL ${urlId} tracked for budget update in campaign ${campaignId}`,
        clicksTracked: clicksToTrack,
        processingTime: req.body.immediate ? 'Immediate' : '10 minutes'
      });
    } catch (error) {
      console.error('Error testing URL budget update:', error);
      res.status(500).json({
        success: false,
        message: "Error testing URL budget update functionality",
        error: String(error)
      });
    }
  });

  // Create an HTTP/2 capable server
  // We're using a regular HTTP server instead of SPDY for now due to compatibility issues
  // We'll handle the HTTP/2.0 headers in the individual route handlers
  return server;
}

==> /app/server/auth/routes.ts <==
      res.json({ authenticated: isValid });
    } catch (error) {
      console.error('Auth status error:', error);
      res.json({ authenticated: false });
    }
  });

  // Clear API key cookie (logout)
  app.post('/api/auth/logout', (req: Request, res: Response) => {
    res.clearCookie('apiKey');
    res.json({ message: 'API key cleared' });
  });

  // Test route to verify auth is working
  app.get('/api/auth/test', requireAuth, (req: Request, res: Response) => {
    res.json({
      message: 'Authentication successful - API key is valid'
    });
  });
}
# Add this route to the end of the routes.ts file, before the return statement
# Find the line that returns 'httpServer' and add this right before it:

  app.get('/api/test-simple', (_req, res) => {
    res.json({
      message: 'API is working',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV
    });
  });

# Then use nano or another editor to add this route

root@vultr:/app# # Search for WebSocketServer in routes.ts
grep -n "WebSocketServer" /app/server/routes.ts

# If you find it, comment it out using nano
nano /app/server/routes.ts
root@vultr:/app# # Restart the application
pm2 restart url-manager

# Wait for it to start
sleep 5

# Test the API
curl http://localhost/api/campaigns
Use --update-env to update environment variables
[PM2] Applying action restartProcessId on app [url-manager](ids: [ 2 ])
[PM2] [url-manager](2) ✓
┌────┬────────────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ id │ name           │ namespace   │ version │ mode    │ pid      │ uptime │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├────┼────────────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ 1  │ simple-app     │ default     │ 1.0.0   │ fork    │ 22946    │ 13m    │ 0    │ online    │ 0%       │ 60.1mb   │ root     │ disabled │
│ 2  │ url-manager    │ default     │ 1.0.0   │ fork    │ 24768    │ 0s     │ 107  │ online    │ 0%       │ 4.0kb    │ root     │ disabled │
└────┴────────────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
[{"id":1,"name":"Test Campaign","description":"This is a test campaign","trafficstar_id":null,"custom_path":null,"active":true,"click_threshold_activate":15000,"click_threshold_pause":5000,"created_at":"2025-04-26T12:23:34.520Z","updated_at":"2025-04-26T12:23:34.520Z","last_budget_update":null,"budget_adjusted_today":false,"last_# Look for WebSocket usage in client componentsvultr:/app# # Look for WebSocket usage in client components
find /app/client/src/components -type f -exec grep -l "WebSocket" {} \;

# Also check context providers
find /app/client/src/contexts -type f -exec grep -l "WebSocket" {} \;

# And hooks
find /app/client/src/hooks -type f -exec grep -l "WebSocket" {} \;
root@vultr:/app#
